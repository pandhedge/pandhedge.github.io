---
layout: post
title:  "常见的网络协议"
date:   2025-10-12 20:18:00 +0800
categories: 软件测试
tags: 软件测试 python  
author: PandHedge
mathjax: true
---
## 常见的网络协议

### 一、常见测试用网络协议汇总表（TCP/IP 四层模型视角）

表格清晰梳理协议的层级、核心作用及测试场景，聚焦**测试过程中高频使用**的协议：

| 协议名称                   | TCP/IP 四层模型层级 | 核心作用                                                     | 典型测试场景                                                 |
| -------------------------- | ------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| HTTP（超文本传输协议）     | 应用层              | 基于 TCP 的无状态协议，用于传输网页、接口数据（如 JSON / 表单） | 1. 接口测试（API 请求 / 响应校验）；2. 页面加载性能测试；3. 接口参数合法性测试 |
| HTTPS（HTTP 安全版）       | 应用层              | HTTP + SSL/TLS 加密，保障数据传输安全（防篡改、防窃听）      | 1. HTTPS 证书有效性测试；2. 加密接口的功能 / 性能测试；3. 证书过期 / 错误场景测试 |
| TCP（传输控制协议）        | 传输层              | 面向连接、可靠传输（三次握手建立连接，四次挥手断开，重传丢失数据） | 1. 性能测试（TCP 连接数、并发连接上限）；2. 网络不稳定场景测试（如断连重连）；3. 端口连通性测试 |
| UDP（用户数据报协议）      | 传输层              | 无连接、不可靠传输（速度快，无重传）                         | 1. 实时性场景测试（如视频流、语音通话）；2. 吞吐量测试（如 UDP 数据包丢包率统计） |
| ICMP（互联网控制报文协议） | 网络层              | 用于网络连通性检测、错误反馈（如 “目标不可达”“超时”）        | 1. 服务器 / 设备连通性测试（ping 命令）；2. 网络延迟 / 丢包率测试（traceroute 追踪路由） |
| DNS（域名系统协议）        | 应用层              | 将域名（如[www.baidu.com](https://www.baidu.com/)）解析为 IP 地址（如 180.101.49.12） | 1. 域名解析正确性测试；2. 解析延迟测试；3. 域名劫持 / 故障转移测试 |
| FTP（文件传输协议）        | 应用层              | 基于 TCP，用于服务器与客户端间的文件上传 / 下载              | 1. 文件传输功能测试（上传 / 下载完整性）；2. 传输权限测试（如匿名 / 密码访问） |
| WebSocket（长连接协议）    | 应用层              | 基于 TCP，实现客户端与服务器的双向实时通信（如实时聊天、消息推送） | 1. 长连接稳定性测试（如持续通信不中断）；2. 实时消息同步测试；3. 断连重连测试 |

### 二、网络协议层级与测试场景关联图

通过两张图直观理解协议的层级关系及测试中的实际交互流程：

#### 图 1：TCP/IP 四层模型与测试常用协议对应关系

（自上而下为 “应用层→传输层→网络层→网络接口层”，箭头指向协议所属层级）

```plaintext
┌─────────────────────────────────────── 应用层 ───────────────────────────────────────┐
│  HTTP/HTTPS  (接口测试、网页测试) │DNS  (域名解析测试) │ FTP  (文件传输测试)  │ WebSocket  (长连接测试)  │
├─────────────────────────────────────── 传输层 ───────────────────────────────────────┤
│         TCP  (可靠传输测试、并发连接测试)        │  UDP  (实时性/吞吐量测试)                │
├─────────────────────────────────────── 网络层 ───────────────────────────────────────┤
│                          ICMP  (连通性测试、延迟/丢包测试)                              │
├────────────────────────────────────── 网络接口层 ─────────────────────────────────────┤
│                          （物理硬件相关，测试中较少直接关注）                             │
└─────────────────────────────────────────────────────────────────────────────────────┘
```

#### 图 2：典型测试场景（HTTP 接口测试）的协议交互流程

（以 “Postman 调用登录接口” 为例，展示从域名解析到响应的全流程）

```plaintext
Postman（客户端）                          中间网络/服务器
       │
       │ 1. DNS协议：解析域名（如http://127.0.0.1→127.0.0.1）
       ├────────────────────────────────────→ DNS服务器
       │
       │ 2. TCP协议：三次握手建立连接（客户端↔127.0.0.1:5000）
       ├───────────────────────→ （SYN）
       │
       │ ←─────────────── （SYN+ACK）
       │
       │ ├───────────────────────→ （ACK）
       │
       │ 3. HTTP协议：发送登录请求（携带参数{"admin":"admin","pwd":"123456"}）
       ├────────────────────────────────────→ 应用服务器（127.0.0.1:5000/login）
       │
       │ 4. HTTP协议：服务器返回响应（如200 OK + 登录结果）
       │ ←────────────────────────────────────
       │
       │ 5. TCP协议：四次挥手断开连接（客户端↔服务器）
       ├───────────────────────→ （FIN）
       │
       │ ←─────────────── （ACK）
       │
       │ ←─────────────── （FIN）
       │
       │ ├───────────────────────→ （ACK）
```

### 三、核心总结

1. **应用层协议**是测试重点：接口测试（HTTP/HTTPS）、实时功能测试（WebSocket）、文件测试（FTP）等均围绕应用层协议展开；
2. **传输层协议**影响性能与稳定性：TCP 的 “可靠性” 和 UDP 的 “实时性” 决定测试场景（如并发测试关注 TCP，视频测试关注 UDP）；
3. **网络层协议**用于基础连通性：ICMP（ping）是排查 “服务器是否可达” 的首要工具，DNS 则是域名相关测试的核心。

要理解网络通信的核心逻辑，**TCP/IP 四层模型**是基础框架（对应 OSI 七层模型的简化版），而模型中各层级的 “重要协议” 则是实现通信的核心工具。以下先详细拆解四层模型，再针对测试中高频使用的核心协议展开讲解，全程结合测试场景说明实际价值。

### 一、TCP/IP 四层模型（核心框架详解）

TCP/IP 四层模型将网络通信划分为 4 个层层递进的层级，每一层有明确的职责：**上层依赖下层提供的服务，下层为上层封装数据**（发送时 “封装”，接收时 “解封装”）。其核心作用是 “标准化通信流程”，让不同设备（如电脑、服务器、路由器）能跨厂商协作。

#### 1. 四层模型核心信息表（含职责、数据单位、典型设备）

| 层级（从下到上） | 核心职责                                                     | 数据单位                                  | 典型设备 / 组件             | 关键作用（测试视角）                                         |
| ---------------- | ------------------------------------------------------------ | ----------------------------------------- | --------------------------- | ------------------------------------------------------------ |
| 1. 网络接口层    | 负责 “物理传输”：将上层数据转换为硬件可识别的电信号 / 光信号，处理网卡、网线等硬件交互 | 帧（Frame）                               | 网卡、交换机、集线器        | 测试中较少直接关注（除非排查硬件故障，如网线松动导致的丢包） |
| 2. 网络层        | 负责 “路由转发”：确定数据从 “源 IP” 到 “目标 IP” 的路径，处理 IP 地址和路由选择 | 数据包（Packet）                          | 路由器、网关                | 测试中用于排查 “跨网段连通性”（如 traceroute 追踪路由丢包点） |
| 3. 传输层        | 负责 “端到端可靠传输”：建立主机间的端口通信（如 80 端口、443 端口），保障数据完整性 | 段（Segment，TCP）/ 报头（Datagram，UDP） | 操作系统（TCP/UDP 协议栈）  | 测试核心层（如并发连接测试、丢包重传测试、端口可用性测试）   |
| 4. 应用层        | 负责 “用户交互”：提供具体的应用服务（如网页浏览、文件传输、接口调用） | 数据（Data）                              | 浏览器、Postman、FTP 客户端 | 测试最高频层（如接口测试、HTTPS 证书测试、WebSocket 实时性测试） |

#### 2. 四层模型数据流转过程（理解 “封装 / 解封装”）

以 “Postman 调用服务器接口” 为例，数据从应用层到网络接口层的**封装流程**（发送端）：

1. **应用层**：Postman 构造 HTTP 请求数据（如`{"admin":"admin"}`），传递给传输层；
2. **传输层**：添加 TCP 头（含源端口、目标端口，如源端口 54321→目标端口 5000），形成 “TCP 段”，传递给网络层；
3. **网络层**：添加 IP 头（含源 IP、目标 IP，如 192.168.1.100→127.0.0.1），形成 “IP 数据包”，传递给网络接口层；
4. **网络接口层**：添加帧头（含网卡 MAC 地址），转换为电信号，通过网线 / 无线发送。

接收端（服务器）则反向 “解封装”：先拆帧头→拆 IP 头→拆 TCP 头→最终拿到应用层的 HTTP 数据，交给应用程序处理。

### 二、测试中核心协议的详细解析（按四层模型分类）

以下协议是测试过程中**必须掌握**的核心，重点讲解 “原理 + 关键特性 + 测试场景”，避免纯理论堆砌。

#### （一）应用层核心协议（测试最高频）

应用层协议直接对应 “用户可见的服务”，接口测试、Web 测试、文件测试均围绕此层展开。

##### 1. HTTP（超文本传输协议，HyperText Transfer Protocol）

- **核心定位**：基于 TCP 的 “无状态” 应用层协议，用于传输网页、API 接口数据（如 JSON、表单、HTML），默认端口 80。

- 关键特性：

  - 无状态：每次请求独立，服务器不记忆前一次请求（需 Cookie/Token 维持会话）；
  - 请求 - 响应模式：客户端发请求，服务器返回响应，一次交互后 TCP 连接可断开（HTTP/1.1 默认 “keep-alive” 复用连接）；
  - 明文传输：数据不加密，易被窃听或篡改（这是 HTTPS 存在的原因）。
  
- 核心结构（请求 + 响应）：

  - 请求：请求行（`POST /login HTTP/1.1`）+ 请求头（`Content-Type: application/json`）+ 请求体（`{"pwd":"123"}`）；
  - 响应：响应行（`HTTP/1.1 200 OK`）+ 响应头（`Set-Cookie: sessionId=abc`）+ 响应体（`{"code":0,"msg":"success"}`）。
  
- 测试场景：

  - 接口功能测试：校验请求参数、响应状态码（200/400/401/500）、响应体数据；
  - 接口性能测试：统计 HTTP 请求的响应时间、QPS（每秒请求数）；
  - 兼容性测试：验证不同 HTTP 版本（HTTP/1.1、HTTP/2）的兼容性。

##### 2. HTTPS（HTTP Secure，HTTP 安全版）

- **核心定位**：HTTP + SSL/TLS 加密层，解决 HTTP 明文传输的安全问题，默认端口 443。

- 关键特性：

  - 加密传输：数据通过 “对称加密”（传输时）+“非对称加密”（协商密钥时）保障安全；
  - 身份认证：通过 “数字证书”（如 SSL 证书）验证服务器身份，防止 “钓鱼网站”；
  - 数据完整性：通过 “消息摘要” 校验数据，防止传输中被篡改。
  
- 核心流程（SSL/TLS 握手，建立安全连接）：

  1. 客户端发 “客户端 hello”：告知服务器支持的加密算法、SSL 版本；
  2. 服务器发 “服务器 hello + 证书”：确认加密算法，返回服务器证书（含公钥）；
  3. 客户端验证证书：通过 CA 机构（如 Let’s Encrypt）验证证书有效性，生成 “预主密钥”，用服务器公钥加密后发给服务器；
  4. 服务器解密预主密钥：用自身私钥解密，双方基于预主密钥生成 “对称加密密钥”；
  5. 双方用对称密钥通信：后续 HTTP 数据均用对称密钥加密传输。
  
- 测试场景：

  - 证书有效性测试：验证证书过期、证书伪造、证书不匹配（如域名与证书绑定域名不一致）时的处理；
  - 加密强度测试：检查是否支持弱加密算法（如 SHA-1），是否强制使用 TLS 1.2+（禁用不安全的 SSLv3）；
  - 性能测试：对比 HTTPS 与 HTTP 的响应时间差异（加密解密会增加耗时）。

#### 3. DNS（域名系统协议，Domain Name System）

- **核心定位**：将 “域名”（如[www.baidu.com](https://www.baidu.com/)）解析为 “IP 地址”（如 180.101.49.12），解决 “记 IP 难” 的问题。

- 关键特性：

  - 分层解析：从根域名服务器→顶级域名服务器（.com）→权威域名服务器，逐层查询；
  - 缓存机制：本地操作系统、路由器会缓存解析结果，减少重复查询耗时。
  
- 测试场景：

  - 解析正确性测试：验证域名是否能正确解析到目标 IP（用`nslookup www.baidu.com`或`dig`命令）；
  - 解析延迟测试：统计域名解析耗时（性能测试中需排除解析延迟对接口响应时间的影响）；
  - 故障转移测试：验证域名绑定多个 IP 时，某 IP 不可用是否能自动解析到其他 IP（如负载均衡场景）。

#### （二）传输层核心协议（性能与稳定性测试关键）

传输层协议负责 “端到端的可靠通信”，是并发测试、丢包测试、端口测试的核心。

##### 1. TCP（传输控制协议，Transmission Control Protocol）

- **核心定位**：基于 IP 的 “面向连接、可靠传输” 协议，适用于对数据完整性要求高的场景（如 HTTP、FTP、数据库连接）。

- 关键特性：

  - 面向连接：通信前必须通过 “三次握手” 建立连接，通信后通过 “四次挥手” 断开连接；
  - 可靠传输：通过 “确认应答”（ACK）、“重传机制”（丢包后重发）、“流量控制”（滑动窗口）、“拥塞控制”（避免网络拥堵）保障数据不丢、不重复、有序；
  - 面向字节流：数据以字节为单位传输，无固定数据包大小。
  
- 核心流程（三次握手 + 四次挥手）：

  - 三次握手（建立连接，确保双方收发能力正常）：

    1. 客户端发`SYN`（同步信号）：“我要连接你，初始序列号是 x”；
    2. 服务器回`SYN+ACK`（同步 + 确认）：“我收到了，我的初始序列号是 y，确认你的 x”；
    3. 客户端回`ACK`（确认）：“我收到你的 y，连接建立”。
    
  - 四次挥手（断开连接，确保双方数据都发完）：
  
    1. 客户端发`FIN`（结束信号）：“我数据发完了，要断开”；
    2. 服务器回`ACK`：“我收到断开请求，等我发完剩余数据”；
    3. 服务器发`FIN`：“我数据也发完了，断开”；
    4. 客户端回`ACK`：“收到，断开连接”。
  
- 测试场景：

  - 并发连接测试：验证服务器能支撑的最大 TCP 连接数（如用`ab`工具压测，看是否出现 “连接超时”）；
  - 断连重连测试：模拟 TCP 连接突然断开（如拔网线），验证客户端是否能自动重连；
  - 拥塞测试：模拟网络拥堵（如用`tc`命令限速），观察 TCP 的拥塞控制是否生效（如数据传输速率下降后恢复）。

##### 2. UDP（用户数据报协议，User Datagram Protocol）

- **核心定位**：基于 IP 的 “无连接、不可靠传输” 协议，适用于对实时性要求高、可容忍少量丢包的场景（如视频流、语音通话、DNS 查询）。

- 关键特性：

  - 无连接：通信前无需建立连接，直接发数据，效率高；
  - 不可靠：无确认应答、无重传机制，数据可能丢包、乱序；
  - 面向数据报：数据以 “数据报” 为单位传输，每个数据包独立。
  
- 测试场景：

  - 实时性测试：验证 UDP 传输的延迟（如视频通话的画面延迟）；
  - 丢包率测试：模拟网络丢包（如用`tc`命令丢包 10%），观察应用是否能容忍（如视频卡顿是否可接受）；
  - 吞吐量测试：测试 UDP 的最大传输速率（无连接特性使其吞吐量高于 TCP）。

#### （三）网络层核心协议（连通性测试基础）

网络层协议负责 “路由和寻址”，是排查 “服务器是否可达” 的核心工具。

##### ICMP（互联网控制报文协议，Internet Control Message Protocol）

- **核心定位**：辅助 IP 协议，用于传递 “控制信息”（如连通性确认、错误提示），不传输用户数据。

- 关键特性：

  - 无端口：直接基于 IP 协议，无需端口（区别于 TCP/UDP）；
  - 常用报文类型：`echo请求`（ping 请求）、`echo应答`（ping 响应）、`目标不可达`（如 IP 不存在）、`超时`（如路由跳数超限）。
  
- 测试场景：

  - 基础连通性测试：用`ping 127.0.0.1`验证服务器是否可达（丢包率为 0 表示连通正常）；
  - 网络延迟测试：通过`ping`的 “平均延迟” 判断网络质量（如延迟 > 100ms 可能影响实时应用）；
  - 路由追踪测试：用`traceroute 127.0.0.1`（Windows 用`tracert`）追踪数据传输的路由节点，定位丢包的具体网段。

### 三、总结：四层模型与核心协议的关联（测试视角）

| 测试需求                  | 依赖的层级 | 核心协议   | 常用工具 / 命令             |
| ------------------------- | ---------- | ---------- | --------------------------- |
| 接口功能 / HTTPS 安全测试 | 应用层     | HTTP/HTTPS | Postman、JMeter、curl       |
| 并发 / 稳定性测试         | 传输层     | TCP        | JMeter、ab（Apache Bench）  |
| 实时性 / 吞吐量测试       | 传输层     | UDP        | iperf、JMeter               |
| 服务器连通性 / 路由排查   | 网络层     | ICMP       | ping、traceroute（tracert） |
| 域名解析测试              | 应用层     | DNS        | nslookup、dig               |

掌握以上内容后，即可应对绝大多数网络相关的测试场景：从接口功能验证，到性能压测，再到网络故障排查，都能明确 “依赖哪个协议”“用什么工具测试”“关注什么指标”。



## cookies和token

Cookies 和 Token 是 Web 应用中最常用的两种**身份认证与会话保持技术**，核心作用是让服务器识别 “当前请求来自哪个用户”，避免用户每次操作都重复登录。两者的实现原理、使用场景和安全性差异显著，以下从**定义、工作流程、核心特性、对比、测试关注点**五个维度详细介绍：

### 一、Cookies（Cookie）：浏览器端的 “身份小票”

Cookies 是**服务器下发给浏览器的小型文本文件**（通常 4KB 以内），存储在客户端（浏览器 / APP），后续请求会自动携带，用于服务器识别用户身份。

#### 1. 核心定义

- 本质：键值对格式的文本数据（如 `sessionId=abc123; username=test`）。
- 控制权：由服务器通过 HTTP 响应头 `Set-Cookie` 主动设置，浏览器被动存储。
- 传输方式：浏览器发起请求时，会自动将符合条件的 Cookie 放入请求头 `Cookie` 中，无需开发者手动处理。

#### 2. 工作流程（以 “用户登录” 为例）

```plaintext
1. 客户端（浏览器）发送登录请求：POST /login，携带用户名密码（如 {"admin":"admin","pwd":"123456"}）
2. 服务器验证通过后，生成会话标识（如 sessionId=abc123），通过响应头下发 Cookie：
   响应头：Set-Cookie: sessionId=abc123; HttpOnly; Secure; Path=/
3. 浏览器接收后，将 Cookie 存储在本地（不同浏览器存储位置不同，如 Chrome 存在本地文件中）
4. 后续客户端发起请求（如访问 /user/info）时，浏览器自动在请求头添加：
   请求头：Cookie: sessionId=abc123
5. 服务器读取 Cookie 中的 sessionId，查询服务器端存储的会话信息（如该 sessionId 对应的用户是谁），确认身份后返回数据
```

#### 3. 核心特性（测试中需关注）

- **自动携带**：浏览器会自动为同一域名的请求携带 Cookie，无需手动添加（这是与 Token 最核心的区别）。

- 存储限制：

  - 大小限制：单个 Cookie 不超过 4KB，一个域名下最多存储 50 个左右（不同浏览器略有差异）。
  - 有效期：分为 “会话 Cookie”（关闭浏览器后失效，无 `Expires`/`Max-Age` 属性）和 “持久 Cookie”（设置了失效时间，如 `Expires=Wed, 31 Dec 2025 23:59:59 GMT`）。
  
- 安全性配置

  （关键测试点）：

  - `HttpOnly`：禁止 JavaScript 读取 Cookie，防止 XSS 攻击（若未设置，前端可通过 `document.cookie` 获取，存在被盗风险）。
  - `Secure`：仅在 HTTPS 协议下传输 Cookie，防止 HTTP 明文传输时被窃听。
  - `SameSite`：限制 Cookie 跨域携带（如 `SameSite=Strict` 仅同域请求携带，防止 CSRF 攻击）。

- **服务器依赖**：需要服务器存储会话信息（如 sessionId 对应的用户数据），通常存在内存、Redis 中，对服务器有存储压力。

### 二、Token：客户端自主携带的 “身份令牌”

Token 是**服务器生成的一串加密字符串**，作为用户身份的 “临时凭证”，由客户端（浏览器 / APP）主动存储和携带，不依赖浏览器自动传输。

#### 1. 核心定义

- 本质：无固定格式的字符串（如 `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...`，即 JWT）。
- 控制权：服务器生成后返回给客户端，客户端自主选择存储位置（如浏览器 `LocalStorage`/`SessionStorage`、APP 内存）。
- 传输方式：需开发者手动将 Token 放入请求头（如 `Authorization: Bearer <Token>`）、请求体或 URL 参数中（推荐请求头，安全性更高）。

#### 2. 工作流程（以最常用的 JWT Token 为例）

```plaintext
1. 客户端发送登录请求：POST /login，携带用户名密码
2. 服务器验证通过后，生成 JWT Token（结构：头部 Header + 载荷 Payload + 签名 Signature）：
   - 头部：指定加密算法（如 HS256）
   - 载荷：存储用户信息（如 userId=123, username=admin，可解码但不可篡改）
   - 签名：用服务器密钥对头部+载荷加密，防止 Token 被篡改
3. 服务器将 Token 直接返回给客户端（如响应体：{"code":0,"token":"eyJhbGciOiJIUzI1Ni..."}）
4. 客户端存储 Token（如浏览器存入 LocalStorage：localStorage.setItem("token", "eyJhbGciOiJIUzI1Ni...")）
5. 后续请求时，客户端手动在请求头添加 Token：
   请求头：Authorization: Bearer eyJhbGciOiJIUzI1Ni...
6. 服务器接收后，用密钥验证 Token 签名（确认未被篡改），解码载荷获取用户信息，完成身份认证
```

#### 3. 核心特性（测试中需关注）

- **手动携带**：需开发者在代码中显式添加 Token 到请求头 / 体（如 Postman 中需手动配置 `Authorization` 头），浏览器不会自动携带。

- 存储灵活：

  - 无大小限制（取决于存储介质，如 LocalStorage 通常支持 5MB）。
  - 存储位置可选：浏览器（LocalStorage/SessionStorage/ 内存）、APP 内存（更安全，避免被窃取）。
  
- **无服务器存储**：Token 本身包含用户信息（如 JWT 载荷），服务器无需存储会话数据，仅需通过密钥验证有效性，减轻服务器压力（适合分布式系统）。

- 安全性：

  - 依赖传输安全：需通过 HTTPS 传输，防止 Token 被窃听。
  - 有效期可控：Token 会设置过期时间（如 JWT 载荷中的 `exp` 字段），过期后需重新获取（如用刷新令牌 Refresh Token 自动续期）。
  - 易被 XSS 窃取：若存储在 LocalStorage，前端 JS 可读取，存在 XSS 攻击风险（需配合前端防护，如输入过滤）。

### 三、Cookies vs Token：核心区别对比（测试必知）

| 对比维度       | Cookies                                  | Token                                               |
| -------------- | ---------------------------------------- | --------------------------------------------------- |
| **存储位置**   | 浏览器指定目录（仅客户端）               | 灵活（LocalStorage / 内存 / APP 存储）              |
| **传输方式**   | 浏览器自动携带（请求头 `Cookie`）        | 手动携带（通常请求头 `Authorization`）              |
| **大小限制**   | 单个 ≤4KB，域名下数量有限（≈50 个）      | 无固定限制（取决于存储介质）                        |
| **服务器存储** | 需存储会话信息（如 sessionId 对应用户）  | 无需存储（Token 自带用户信息，仅验签名）            |
| **跨域支持**   | 支持差（受同源策略限制，需配置 CORS）    | 支持好（跨域请求可手动携带，无同源限制）            |
| **安全性**     | 可通过 `HttpOnly`/`Secure` 提升安全性    | 依赖 HTTPS 和存储位置（LocalStorage 易被 XSS 窃取） |
| **适用场景**   | 传统 Web 项目（如 JSP/PHP 后端渲染）     | 前后端分离、APP、API 服务（如 React/Vue 项目）      |
| **测试关注点** | 检查 `Set-Cookie` 属性、自动携带是否生效 | 检查 Token 有效期、篡改后是否拒绝、跨域携带是否正常 |

### 四、测试场景中的核心关注点

无论是测试基于 Cookies 还是 Token 的系统，需重点验证 “身份认证有效性” 和 “安全性”：

#### 1. Cookies 测试重点

- **Cookie 生成验证**：登录成功后，检查响应头 `Set-Cookie` 是否包含关键字段（如 `sessionId`），是否设置 `HttpOnly`/`Secure`/`SameSite` 属性。

- **自动携带验证**：登录后发起其他请求（如 /user/info），检查请求头是否自动携带 `Cookie`，且 `sessionId` 正确。

- 有效期验证：

  - 会话 Cookie：关闭浏览器后，再次请求是否需要重新登录。
  - 持久 Cookie：设置过期时间后，到期后是否返回 401 未授权。
  
- 安全性测试：

  - 无 `HttpOnly`：尝试用前端 JS（`document.cookie`）是否能读取 Cookie（若能，则存在 XSS 风险）。
- 无 `Secure`：HTTP 协议下是否仍能携带 Cookie（若能，则存在窃听风险）。

#### 2. Token 测试重点

- **Token 生成与返回**：登录成功后，检查响应体是否包含 Token，格式是否正确（如 JWT 是否有三段式结构）。

- 携带有效性：

  - 正常携带：添加 Token 到请求头，检查是否能正常访问接口（返回 200）。
  - 不携带 Token：请求接口是否返回 401/403（未授权）。
  
- 有效期与篡改：

  - 过期测试：用过期 Token 请求，是否返回 401，是否支持刷新 Token 续期。
  - 篡改测试：修改 Token 任意字符（如改 JWT 载荷中的 `userId`），请求是否返回 401（签名验证失败）。
  
- **跨域测试**：跨域请求（如前端域 `http://a.com` 调用后端域 `http://b.com`），检查 Token 是否能正常携带，接口是否正常响应。

### 五、总结

- **Cookies**：“浏览器自动管理的身份小票”，适合传统 Web 项目，安全性可通过配置提升，测试重点在自动携带和属性验证。
- **Token**：“手动管理的身份令牌”，适合前后端分离、APP 项目，跨域支持好，测试重点在有效期、篡改防护和手动携带。

理解两者的差异，能帮助你在测试中快速定位 “身份认证失败” 的原因（如 Cookies 未自动携带、Token 过期 / 未携带），同时保障系统的认证安全性。



## HTTP 方法

在 HTTP 协议中，GET、POST、PUT、DELETE 等请求方式（也称 “HTTP 方法”）的核心区别在于**语义定义、数据传输方式、使用场景**，以及对服务器资源的 “影响行为”（如是否修改资源）。以下从 “核心区别维度” 和 “常见方法详解” 两部分展开，结合测试场景说明实际应用差异。

### 一、HTTP 请求方法的核心区别维度（表格对比）

先通过表格直观对比 6 种常用方法的关键差异，覆盖 “语义、数据传输、安全性、幂等性” 等测试高频关注维度：

| 对比维度         | GET                                  | POST                                   | PUT                      | DELETE                  | PATCH                          | HEAD                                            |
| ---------------- | ------------------------------------ | -------------------------------------- | ------------------------ | ----------------------- | ------------------------------ | ----------------------------------------------- |
| **核心语义**     | 从服务器**获取**资源                 | 向服务器**提交**资源（创建 / 修改）    | 全量**更新**资源（替换） | **删除**资源            | 部分**更新**资源（修改局部）   | 仅获取响应头（同 GET，无响应体）                |
| **数据传输位置** | URL 参数（如`?id=1`）                | 请求体（如 JSON / 表单）               | 请求体（如完整资源数据） | URL 参数（如`/user/1`） | 请求体（如局部字段）           | URL 参数（同 GET）                              |
| **数据大小限制** | 有限制（URL 长度限制，通常几 KB）    | 理论无限制（服务器可配置上限）         | 理论无限制               | 有限制（同 GET）        | 理论无限制                     | 有限制（同 GET）                                |
| **参数可见性**   | 可见（URL 中暴露，易被日志记录）     | 不可见（请求体中，需抓包查看）         | 不可见（请求体）         | 可见（URL）             | 不可见（请求体）               | 可见（URL）                                     |
| **安全性**       | 语义安全（不修改资源），但参数易泄露 | 语义不安全（修改资源），参数隐私性更好 | 语义不安全（修改资源）   | 语义不安全（删除资源）  | 语义不安全（修改资源）         | 语义安全（同 GET）                              |
| **可缓存性**     | 默认可缓存（浏览器 / 代理缓存响应）  | 默认不可缓存                           | 默认不可缓存             | 默认不可缓存            | 默认不可缓存                   | 默认可缓存（缓存响应头）                        |
| **幂等性***      | 是（多次请求结果一致）               | 否（多次请求可能创建多个资源）         | 是（多次更新结果一致）   | 是（多次删除结果一致）  | 否（部分更新可能叠加影响）     | 是（同 GET）                                    |
| **典型使用场景** | 查询数据（如列表、详情）             | 提交表单、上传文件、创建资源           | 更新用户信息（全量替换） | 删除用户、删除订单      | 修改密码（仅传 password 字段） | 检查资源是否存在（如 HEAD /user/1，看是否 200） |

> *注：**幂等性**指 “多次执行相同请求，服务器资源状态与执行一次相同”（不产生副作用）。例如：多次 GET /user/1，资源不变；多次 POST /order，可能创建多个订单（非幂等）。*

### 二、重点方法深度解析（GET vs POST 是高频考点）

#### 1. GET：最常用的 “获取资源” 方法

##### 核心特点：

- **数据在 URL**：参数通过 “键值对” 拼接在 URL 末尾（如 `http://api.com/user?name=admin&age=20`），多个参数用`&`分隔。
- **无请求体**：即使手动添加请求体，大部分服务器也会忽略（HTTP 协议允许 GET 带请求体，但无实际意义，且不符合语义）。
- **可缓存**：浏览器会缓存 GET 请求的响应（如刷新页面时，若 URL 不变，可能直接用缓存结果），适合静态资源（如图片、HTML）或不常变的查询（如商品详情）。

##### 测试关注点：

- 检查参数是否在 URL 中正确拼接（如特殊字符是否转义，如空格转`%20`）；
- 验证缓存是否生效（如多次请求相同 URL，响应头是否有`Cache-Control`/`Expires`字段）；
- 测试 URL 长度限制（如参数过长时，是否返回 414 Request-URI Too Long）。

#### 2. POST：最常用的 “提交资源” 方法

##### 核心特点：

- **数据在请求体**：参数放在请求体中，支持多种格式（如`application/json`、`multipart/form-data`（上传文件）、`application/x-www-form-urlencoded`（表单）），需通过`Content-Type`头指定格式。
- **可修改资源**：语义上用于 “创建资源”（如 POST /order 创建订单）或 “执行非幂等操作”（如支付），多次请求可能产生不同结果。
- **不可缓存**：默认不被缓存（响应头通常有`Cache-Control: no-cache`），因为每次提交可能改变服务器状态。

##### 测试关注点：

- 检查`Content-Type`与请求体格式是否匹配（如声明`application/json`，但请求体是表单格式，会返回 400 错误）；
- 测试重复提交防护（如多次 POST /pay，是否防止重复扣款，返回 409 Conflict）；
- 验证文件上传场景（如 POST `multipart/form-data`，检查文件是否成功上传到服务器）。

#### 3. PUT vs PATCH：两种 “更新资源” 方法的区别

##### 相同点：

- 均用于 “更新资源”，数据放在请求体中，默认不可缓存，非语义安全。

##### 核心区别（**全量更新 vs 部分更新**）：

- PUT：

  全量更新

  —— 需传递资源的 “完整字段”，即使某些字段未修改（如更新用户信息时，需传 name、age、email 所有字段，未传字段可能被置空）；

  

  示例：PUT /user/1，请求体

  ```
{"name":"newAdmin","age":25,"email":"new@test.com"}
  ```
  
  （需包含所有用户字段）。

- PATCH：

  部分更新

  —— 仅传递 “需要修改的字段”，未传递字段保持原有值（更高效，减少数据传输）；

  

  示例：PATCH /user/1，请求体

  ```
  {"age":26}
  ```
  
  （仅更新年龄，name 和 email 不变）。

##### 测试关注点：

- PUT：验证未传字段是否被置空（如仅传 age，name 是否变为 null）；
- PATCH：验证未传字段是否保持原值（避免误改无关字段）。

#### 4. DELETE：“删除资源” 方法

##### 核心特点：

- **语义明确**：用于删除服务器上的资源（如 DELETE /user/1 删除 ID 为 1 的用户），参数通常通过 URL 路径或 URL 参数传递（如`/user?id=1`）。
- **幂等性**：多次执行相同 DELETE 请求，结果一致（如第一次删除返回 200，第二次删除可能返回 404 Not Found，但资源状态仍为 “已删除”，符合幂等性）。

##### 测试关注点：

- 验证删除后资源是否真的不存在（如 DELETE /user/1 后，GET /user/1 是否返回 404）；
- 测试权限控制（如普通用户删除管理员账号，是否返回 403 Forbidden）。

#### 5. HEAD：“仅获取响应头” 的特殊方法

##### 核心特点：

- **行为同 GET，无响应体**：请求逻辑与 GET 完全一致（如 HEAD /user/1 等同于 GET /user/1），但服务器仅返回响应头（如`Content-Type`、`Content-Length`），不返回响应体。
- **用途**：快速检查资源状态（如是否存在、资源大小），避免传输响应体浪费带宽（如检查大文件是否存在，用 HEAD 比 GET 更高效）。

##### 测试关注点：

- 验证响应头是否与 GET 一致（如 HEAD /user/1 的 `Content-Length` 是否等于 GET /user/1 的响应体大小）；
- 检查是否真的无响应体（避免服务器错误返回响应体）。

### 三、常见误区澄清（测试中易混淆的点）

1. **“GET 不安全，POST 安全”？**错误。两者的 “传输安全” 仅取决于是否用 HTTPS：

   - GET 参数在 URL 中，若用 HTTP，易被抓包窃取；

   - POST 参数在请求体中，若用 HTTP，同样可被抓包（如用 Fiddler/Wireshark）；

     

     正确理解：POST 的 “隐私性” 略好（参数不暴露在 URL 日志中），但核心安全需依赖 HTTPS。

2. **“GET 只能传文本，POST 能传二进制”？**错误。GET 理论上可通过 URL 传二进制（需 Base64 编码），但受 URL 长度限制，且编码后体积变大；POST 通过`multipart/form-data`格式，更适合传二进制（如图片、文件），是实际开发中的首选，但非 “唯一可能”。

3. **“PUT 是创建资源，POST 是更新资源”？**错误。语义反了：

   - POST 通常用于 “创建资源”（如 POST /order 创建订单）；

   - PUT 通常用于 “更新资源”（如 PUT /user/1 更新用户）；

     

     例外：PUT 也可用于 “创建资源”（如 PUT /user/1，若用户 1 不存在，则创建），但需满足 “幂等性”（多次 PUT 相同数据，仅创建一次）。

### 四、总结（按场景选方法）

| 业务场景               | 推荐方法 | 核心原因                     |
| ---------------------- | -------- | ---------------------------- |
| 查询商品列表、用户详情 | GET      | 语义匹配（获取资源），可缓存 |
| 提交登录表单、创建订单 | POST     | 语义匹配（提交资源），非幂等 |
| 全量更新用户信息       | PUT      | 语义匹配（全量更新），幂等   |
| 部分更新密码、手机号   | PATCH    | 语义匹配（部分更新），高效   |
| 删除订单、删除用户     | DELETE   | 语义匹配（删除资源），幂等   |
| 检查文件是否存在、大小 | HEAD     | 无需响应体，节省带宽         |

理解这些区别后，在测试中能更精准地设计用例（如 POST 测重复提交，PUT 测全量更新逻辑），也能快速定位 “方法使用错误” 的问题（如用 GET 提交敏感密码，用 POST 查询数据）。

# 结尾