---
layout: post
title:  "Python 基础知识"
date:   2025-09-09 18:19:00 
categories: Daily
tags: Daily 
author: PandHedge
mathjax: true
---
* content
{:toc}
* content
{:toc}




# Python

## 精通Python编程从零基础到实战

## 8.1 Python初阶：基础语法

### Python简介&环境搭建&以及环境变量原理

   ### Python常用IDE以及免安装开发环境（如Anaconda、PyCharm等）

   ### Python基础语法和基本数据类型（Number、String）

  ##### 一、基础语法

    1. **注释**：用于解释代码，不被执行

    单行注释：以 `#` 开头

  ```python
 # 这是一条单行注释
 print("Hello World")  # 这也是注释，在代码后面
  ```

   多行注释：用三个单引号 `'''` 或三个双引号 `"""` 包裹

   ```python
'''
这是多行注释第一行
这是多行注释第二行
'''
   ```

   **缩进**：Python 用缩进来区分代码块，通常使用 4 个空格

   ```python
if 5 > 2:
   print("5 大于 2")  # 缩进部分属于 if 代码块
   ```

      2. **变量**：用于存储数据，无需声明类型，直接赋值

   ```python
x = 10  # 整数
name = "Alice"  # 字符串
   ```

      3. **关键字**：Python 保留的特殊单词，不能作为变量名，如 `if`、`else`、`for`、`while` 等

  ##### 二、基本数据类型：Number（数字）

   包含整数（int）、浮点数（float）、复数（complex）

      1. **整数（int）**：没有小数部分的数字

   ```python
a = 10
b = 5
c = 0
   ```

      2. **浮点数（float）**：带小数部分的数字

   ```python
x = 3.14
y = 0.5
z = 2.0  # 虽然值是整数，但类型是 float
   ```

      3. **复数（complex）**：由实部和虚部组成，虚部用 `j` 表示

   ```python
m = 3 + 4j
n = 5j  # 实部为 0 的复数
   ```

      4. **数字运算**

   ```python
# 基本运算
print(5 + 3)  # 加法，输出 8
print(10  4)  # 减法，输出 6
print(3 * 7)  # 乘法，输出 21
print(15 / 4)  # 除法，输出 3.75
print(15 // 4)  # 整除，输出 3
print(15 % 4)  # 取余，输出 3
print(2 **3)  # 幂运算，输出 8（2的3次方）
   ```

##### 三、基本数据类型：String（字符串）

   由字符组成的序列，用单引号 `'` 或双引号 `"` 包裹

   1.**字符串定义**

   ```python
s1 = 'Hello'
s2 = "World"
s3 = ''' 多行字符串 ''' # 三个单引号可定义多行字符串
   ```


   2.**字符串访问** 通过索引访问单个字符（索引从 0 开始）

   ```python
s = "Python"
print(s[0])  # 输出 'P'
print(s[1])  # 输出 'n'（1 表示最后一个字符）
   ```

    切片：获取子字符串 `[起始索引:结束索引:步长]`

   ```python
s = "Hello World"
print(s[0:5])  # 输出 'Hello'（从索引0到4，不包含5）
print(s[6:])  # 输出 'World'（从索引6到结尾）
print(s[::2])  # 输出 'HloWrd'（步长为2，间隔取字符）
   ```

   3.**字符串常用操作**
   s = "Hello"

**拼接字符串**

   print (s + "World") # 输出 'Hello World'

**重复字符串**

   print (s * 2) # 输出 'HelloHello'

**字符串长度**

   print (len (s)) # 输出 5

**转换为大写 / 小写**

   print (s.upper ()) # 输出 'HELLO'
   print (s.lower ()) # 输出 'hello'

**替换字符**

   print (s.replace ('l', 'x')) # 输出 'Hexxo'

**分割字符串**

   print ("a,b,c".split (',')) # 输出 ['a', 'b', 'c']






   ### Python高级数据类型（Tuple、List、Set、Dict）

   Python 中的高级数据类型用于存储和组织复杂的数据集合，主要包括 Tuple（元组）、List（列表）、Set（集合）和 Dict（字典）。它们各有特点，适用于不同场景。

  ##### 一、List（列表）

   列表是有序、可变的元素集合，元素可以重复，用方括号 `[]` 表示。

      1. **定义与基本操作**

   ```python
# 定义列表
fruits = ["apple", "banana", "cherry"]
numbers = [1, 2, 3, 4]
mixed = [1, "hello", 3.14, True]  # 可包含不同类型元素

# 访问元素（通过索引）
print(fruits[0])  # 输出 'apple'
print(fruits[1])  # 输出 'cherry'（最后一个元素）

# 修改元素
fruits[1] = "orange"
print(fruits)  # 输出 ['apple', 'orange', 'cherry']
   ```

      2. **常用方法**

   ```python
fruits = ["apple", "banana", "cherry"]

fruits.append("date")  # 添加元素到末尾
print(fruits)  # ['apple', 'banana', 'cherry', 'date']

fruits.insert(1, "blueberry")  # 在指定位置插入
print(fruits)  # ['apple', 'blueberry', 'banana', 'cherry', 'date']

fruits.remove("banana")  # 删除指定元素
print(fruits)  # ['apple', 'blueberry', 'cherry', 'date']

popped = fruits.pop()  # 删除并返回最后一个元素
print(popped)  # 'date'

print(len(fruits))  # 输出 3（列表长度）
   ```

  ##### 二、Tuple（元组）

   元组是有序、不可变的元素集合，元素可以重复，用圆括号 `()` 表示。

      1. **定义与特点**

   ```python
# 定义元组
colors = ("red", "green", "blue")
single = (5,)  # 单个元素的元组需加逗号

# 访问元素（与列表相同）
print(colors[1])  # 输出 'green'

# 元组不可修改（会报错）
# colors[0] = "yellow"  # TypeError
   ```

      2. **常用操作**

   ```python
numbers = (1, 2, 3, 4, 3)

print(len(numbers))  # 输出 5（长度）
print(numbers.count(3))  # 输出 2（元素出现次数）
print(numbers.index(2))  # 输出 1（元素首次出现的索引）
   ```

   **适用场景**：存储不可变的数据（如坐标、配置信息），或作为字典的键。

  ##### 三、Set（集合）

   集合是无序、不可重复的元素集合，用大括号 `{}` 表示，或通过 `set()` 创建。

      1. **定义与去重特性**

   ```python
# 定义集合
fruits = {"apple", "banana", "cherry", "apple"}  # 自动去重
print(fruits)  # 输出 {'apple', 'banana', 'cherry'}（顺序不固定）

# 从列表创建集合
numbers = set([1, 2, 3, 2, 4])
print(numbers)  # {1, 2, 3, 4}
   ```

      2. **常用方法与运算**

   ```python
a = {1, 2, 3}
b = {3, 4, 5}

a.add(6)  # 添加元素
print(a)  # {1, 2, 3, 6}

a.remove(6)  # 删除元素

print(a.union(b))  # 并集 {1, 2, 3, 4, 5}
print(a.intersection(b))  # 交集 {3}
print(a.difference(b))  # 差集 {1, 2}
   ```

   **适用场景**：去重、集合运算（如交集、并集）。

  ##### 四、Dict（字典）

   字典是键值对（keyvalue）的无序集合，键唯一且不可变，用 `{key: value}` 表示。

      1. **定义与访问**

   ```python
# 定义字典
person = {
   "name": "Alice",
   "age": 30,
   "is_student": False
}

# 访问值（通过键）
print(person["name"])  # 输出 'Alice'
print(person.get("age"))  # 输出 30（get方法更安全，键不存在时返回None）
   ```

      2. **常用操作**

   ```python
person = {"name": "Alice", "age": 30}

person["gender"] = "female"  # 添加新键值对
print(person)  # {'name': 'Alice', 'age': 30, 'gender': 'female'}

person["age"] = 31  # 修改值

del person["gender"]  # 删除键值对

print(person.keys())  # 所有键：dict_keys(['name', 'age'])
print(person.values())  # 所有值：dict_values(['Alice', 31])
print(person.items())  # 所有键值对：dict_items([('name', 'Alice'), ('age', 31)])
   ```

   **适用场景**：存储关联数据（如用户信息、配置参数），通过键快速查找值。

  ##### 总结对比

   | 类型  | 有序性   | 可变性 | 元素重复性 | 定义符号   |
   | 	 |  |  |  |  |
   | List  | 是   | 是    | 允许   | `[]`    |
   | Tuple | 是   | 否    | 允许   | `()`    |
   | Set   | 否   | 是    | 不允许    | `{}`    |
   | Dict  | 3.7 + 是 | 是    | 键不允许   | `{key:val}` |

   根据数据特性选择合适的类型，能让代码更高效、易读。例如：列表适合存储有序序列，字典适合存储键值关联数据，集合适合去重操作。



   ### Python函数和模块基础知识以及高级应用

Python 的函数和模块是构建程序的核心组件，从基础到高级应用涵盖了丰富的编程思想和实践技巧。以下是系统的知识梳理：

### 一、函数基础 

1. **函数定义与调用**

函数通过`def`关键字定义，使用缩进区分代码块：

```python
def greet(name):
    return f"Hello, {name}!"

print(greet("Python"))  # 调用函数
```

2. **参数类型**

- **位置参数**：按顺序传递的参数

位置参数是指**按参数定义顺序传递的参数**，必须按照函数定义时的参数顺序依次提供，否则会导致逻辑错误。

#### 特点：

- 必须按顺序传递，数量需与函数定义一致（除非有默认值）
- 调用时直接写参数值，不指定参数名



- **关键字参数**：指定参数名传递，可改变顺序

关键字参数是指**通过 “参数名 = 值” 形式传递的参数**，可以不按定义顺序传递，因为参数名明确指定了对应的参数。

#### 特点：

- 传递时需指定参数名（`参数名=值`）
- 顺序可以任意调整
- 通常用于可选参数或默认参数



位置参数和关键字参数可以混合使用，但必须遵循 **“位置参数在前，关键字参数在后”** 的原则。



- 默认参数

  ：定义时指定默认值，调用时可省略

  ```python
  def power(base, exp=2):
      return base **exp
  ```

- **可变参数**：接受任意数量参数，用`*`表示元组，`**`表示字典

```python
def sum_all(*args, **kwargs):
    total = sum(args)
    for k, v in kwargs.items():
        total += v
    return total
```

### `*args` 与 `**kwargs` 的特殊作用

- `*args`：收集多余的位置参数，打包成元组（用于可变数量的位置参数）
- `**kwargs`：收集多余的关键字参数，打包成字典（用于可变数量的关键字参数）



3. **返回值**

- 用`return`返回结果，可返回多个值（实际是元组）
- 无`return`时默认返回`None`

### 二、模块基础

1. **模块定义与导入**

- 一个`.py`文件就是一个模块

- 导入方式：

  ```python
  import module_name          # 导入整个模块
  from module_name import func  # 导入特定成员
  from module_name import *    # 导入所有成员（不推荐）
  import module_name as mn     # 别名导入
  ```

2. **包（Packages**）

在 Python 中，包（Packages）是一种组织模块的层级结构，用于管理多个相关模块，使代码结构更清晰、可维护性更高。

- **定义**：包是包含多个模块（`.py`文件）的目录，且必须包含一个特殊文件 `__init__.py`（Python 3.3+ 后允许省略，但仍推荐保留）
- **作用**：避免模块名冲突，实现代码的模块化和层级化管理
- **结构**：包可以嵌套，形成多层级结构
- 一个典型的包结构如下：

```olaintext
mypackage/
├── __init__.py
├── module1.py
├── module2.py
└── subpackage/
    ├── __init__.py
    └── module3.py
```



`__init__.py` **文件的作用**

`__init__.py` 文件是包的标识，主要功能包括：

1. **初始化包**：当包被导入时，会自动执行该文件中的代码
2. **控制导出内容**：通过 `__all__` 变量指定 `from package import *` 时导入的模块列表

```python
# mypackage/__init__.py
__all__ = ['module1', 'module2']  # 定义可导出的模块
```

3.**简化导入路径**：在 `__init__.py` 中导入子模块，简化外部导入

```python
# mypackage/__init__.py
from . import module1  # 这样外部可以直接 import mypackage.module1
```

4. **包级别的变量和函数**：定义包级别的常量、函数等

在 Python 中，定义包级别的变量和函数可以让整个包内的模块共享数据或功能，也能对外提供统一的接口。这些变量和函数通常定义在包的 `__init__.py` 文件中，因为该文件会在包被导入时自动执行，是包的初始化入口。

### 一、定义包级别的变量

包级变量可以是常量、配置信息、版本号等，供整个包内的模块或外部导入者使用。

**示例结构**：

```plaintext
mypackage/
├── __init__.py
├── module1.py
└── module2.py
```

**定义方式**：在 `__init__.py` 中直接声明变量：

```python
# mypackage/__init__.py

# 包版本号
__version__ = "1.0.2"

# 作者信息
__author__ = "Alice"

# 包级常量（如配置参数）
MAX_CONNECTIONS = 10
DEFAULT_TIMEOUT = 30

# 包级变量（可被修改）
global_counter = 0
```

**使用方式**：

1. **外部导入使用**：

   ```python
   import mypackage
   print(mypackage.__version__)  # 输出：1.0.2
   print(mypackage.MAX_CONNECTIONS)  # 输出：10
   ```

2. **包内部模块使用**（如 `module1.py`）：

   

   ```python
   # mypackage/module1.py
   from . import __version__, MAX_CONNECTIONS
   
   def get_version():
       return __version__
   
   def check_limit():
       return MAX_CONNECTIONS > 5
   ```

### 二、定义包级别的函数

包级函数是为整个包提供通用功能的函数，例如工具函数、初始化函数等，同样定义在 `__init__.py` 中。

**定义方式**：在 `__init__.py` 中定义函数：

```python
# mypackage/__init__.py

# 包级函数：初始化包配置
def init_config(timeout=None):
    global DEFAULT_TIMEOUT
    if timeout:
        DEFAULT_TIMEOUT = timeout
    print(f"配置初始化完成，超时时间：{DEFAULT_TIMEOUT}")

# 包级工具函数
def format_message(msg):
    return f"[{__version__}] {msg}"
```

**使用方式**：

1. **外部调用**：

   

   ```python
   import mypackage
   mypackage.init_config(60)  # 调用包级函数修改配置
   print(mypackage.format_message("操作完成"))  # 输出：[1.0.2] 操作完成
   ```

2. **内部模块调用**（如 `module2.py`）：

   

   ```python
   # mypackage/module2.py
   from . import format_message
   
   def process():
       message = format_message("处理中")
       print(message)
   ```

### 三、高级技巧：控制包级成员的可见性

通过 `__all__` 变量可以控制 `from mypackage import *` 时对外暴露的成员，避免内部实现细节被意外导入：

```python
# mypackage/__init__.py

# 定义对外暴露的成员（变量、函数、模块）
__all__ = [
    "__version__", 
    "MAX_CONNECTIONS", 
    "init_config", 
    "format_message"
]

# 私有变量（不希望被外部导入）
_internal_secret = "hidden"

# 私有函数
def _helper():
    return _internal_secret
```

此时使用 `from mypackage import *` 只会导入 `__all__` 中列出的成员，保护内部实现。

### 四、注意事项

1. **全局状态管理**：包级变量是全局的，修改后会影响整个程序中使用该包的部分，需谨慎操作（尤其在多线程环境）。
2. **初始化逻辑**：复杂的初始化代码（如读取配置文件、连接数据库）可以放在包级函数中，而非直接写在 `__init__.py` 顶层，避免导入包时就执行耗时操作。
3. **相对导入**：包内部模块引用包级成员时，需使用相对导入（`from . import xxx`），避免绝对路径导致的可移植性问题。
4. **命名规范**：
   - 公开的包级变量 / 函数使用常规命名（如 `MAX_SIZE`、`setup()`）。
   - 内部私有成员以单下划线开头（如 `_internal_var`），表示不建议外部使用。

通过这种方式，能够让包的结构更清晰，对外提供统一的接口，同时方便内部模块共享资源，是大型 Python 项目组织代码的常用技巧。



### 三、包的导入方式

导入包内模块：`from package.subpackage import module`

#### 1. 导入整个包

```python
import mypackage
# 使用：mypackage.module1.function()
```

#### 2. 导入包中的模块

```python
from mypackage import module1
# 或
import mypackage.module1 as m1
```

#### 3. 导入模块中的特定成员

```python
from mypackage.module1 import function1, ClassA
```

#### 4. 导入子包

```python
from mypackage.subpackage import module3
# 或
import mypackage.subpackage.module3
```

#### 5. 通配符导入（需 `__all__` 支持）

```python
from mypackage import *  # 仅导入 __all__ 中指定的模块
```

### 四、相对导入与绝对导入

在包内部模块之间导入时，可以使用：

1. **绝对导入**：从顶层包开始的完整路径

   ```python
   # 在 subpackage/module3.py 中
   from mypackage.module1 import function1
   ```

2. **相对导入**：使用 `.` 表示当前目录，`..` 表示父目录（仅在包内部使用）

   ```python
   # 在 subpackage/module3.py 中
   from ..module1 import function1  # 导入父包中的 module1
   from . import some_module        # 导入同目录下的模块
   ```

### 五、包的高级应用

#### 1. 命名空间包

用于将多个目录合并为一个逻辑包，无需 `__init__.py`，适合大型项目的代码拆分：

```plaintext
project/
├── part1/
│   └── mypackage/
│       └── moduleA.py
└── part2/
    └── mypackage/
        └── moduleB.py
```

通过设置 `PYTHONPATH` 包含 `part1` 和 `part2`，可以将两个 `mypackage` 视为一个包。

#### 2. 条件导入

根据不同环境导入不同模块，提高包的兼容性：

```python
# mypackage/__init__.py
import sys
if sys.version_info >= (3, 10):
    from . import new_features
else:
    from . import legacy_support
```

#### 3. 包的版本管理

在 `__init__.py` 中定义版本信息，方便用户查看：

```python
# mypackage/__init__.py
__version__ = '1.0.0'
__author__ = 'Your Name'
```

用户可通过以下方式获取：

```python
import mypackage
print(mypackage.__version__)  # 输出：1.0.0
```

#### 4. 包的分发

将包打包为可安装的发行版，需创建 `setup.py` 或 `pyproject.toml`，例如：

```python
# setup.py
from setuptools import setup, find_packages

setup(
    name="mypackage",
    version="1.0.0",
    packages=find_packages(),
)
```

### 六、最佳实践

1. 始终在包目录中添加 `__init__.py`，明确标识包并控制导出内容
2. 避免使用 `from package import *`，除非是有意设计的公共 API
3. 包内部优先使用相对导入，外部使用绝对导入
4. 大型项目采用分层结构，合理划分子包
5. 通过 `__all__` 明确指定公共接口，隐藏内部实现细节

掌握包的使用可以帮助你构建结构清晰、易于维护的大型 Python 项目，是从脚本开发转向工程化开发的重要一步。



3. **模块搜索路径**

Python 按以下顺序查找模块：

1. 当前目录
2. 环境变量`PYTHONPATH`指定的路径
3. Python 安装目录的标准库路径

可通过`sys.path`查看和修改搜索路径。

### 三、函数高级应用

1. **匿名函数（lambda）**

简洁的单行函数，适用于简单逻辑：

```python
add = lambda x, y: x + y
print(add(3, 5))  # 输出：8
```

​	在 Python 中，`lambda` 是用于创建匿名函数的关键字，它允许你快速定义简单的、单行的函数，而无需使用 `def` 关键字进行完整的函数定义。

**lambda 的特点**：

1. **匿名性**：lambda 函数没有正式名称，通常通过赋值给变量来使用
2. **简洁性**：只能包含一个表达式，适合简单逻辑
3. **单行性**：通常写在一行内
4. **表达式限制**：只能是单个表达式，不能包含复杂结构（如循环、条件语句只能用三元表达式）

**与普通函数的对比**：

上面的 lambda 表达式等价于：

```python
def add(x, y):
    return x + y
```

### 常见用途：

1. 作为简单函数的快捷方式，尤其是在需要临时函数的场景

2. 与高阶函数（如 `map()`、`filter()`、`sorted()`）配合使用：

   ```python
   numbers = [(1, 3), (4, 1), (2, 5)]
   # 按元组第二个元素排序
   sorted_numbers = sorted(numbers, key=lambda x: x[1])
   ```

3. 作为回调函数或简单的处理逻辑

lambda 适合处理简单的运算或逻辑，对于复杂功能，仍建议使用 `def` 定义常规函数以保证可读性。

#### 2. 函数式编程工具

- Python 提供了一系列函数式编程工具，这些工具允许你以函数为核心进行编程，强调使用纯函数、不可变数据和函数组合。以下是主要的函数式编程工具及其应用：

  ### 一、核心内置函数

  #### 1. `map(func, iterable)`

  - **功能**：将函数 `func` 应用于可迭代对象 `iterable` 的每个元素，返回一个迭代器。

    ```python
    numbers = [1, 2, 3, 4]
    squared = map(lambda x: x** 2, numbers)
    print(list(squared))  # 输出：[1, 4, 9, 16]
    ```

  #### 2. `filter(func, iterable)`

  - **功能**：通过函数 `func` 过滤可迭代对象，保留 `func` 返回 `True` 的元素，返回迭代器。

    ```python
    numbers = [1, 2, 3, 4, 5, 6]
    even_numbers = filter(lambda x: x % 2 == 0, numbers)
    print(list(even_numbers))  # 输出：[2, 4, 6]
    ```

  #### 3. `reduce(func, iterable[, initial])`

  - **功能**：从左到右累积应用函数 `func` 到可迭代对象的元素，最终得到单个结果（需从 `functools` 导入）。

    

    ```python
    from functools import reduce
    numbers = [1, 2, 3, 4]
    product = reduce(lambda x, y: x * y, numbers)  # 1*2*3*4
    print(product)  # 输出：24
    ```

  ### 二、`functools` 模块工具

  #### 1. `functools.partial`

  - **功能**：固定函数的部分参数，生成一个新的简化函数（函数柯里化）。

  - 

    ```python
    from functools import partial
    
    def power(base, exp):
        return base **exp
    
    square = partial(power, exp=2)  # 固定指数为2
    print(square(5))  # 输出：25（等价于 power(5, 2)）
    ```



#### 2. 装饰器（Decorators）

动态增强函数功能，不修改原函数代码：

```python
def log_decorator(func):
    def wrapper(*args, **kwargs):
        print(f"Calling {func.__name__}")
        result = func(*args, **kwargs)
        print(f"{func.__name__} returned {result}")
        return result
    return wrapper

@log_decorator
def add(a, b):
    return a + b

add(2, 3)  # 会自动添加日志功能
```



**`@functools.wraps(func)`：保留被装饰函数的元信息（如名称、文档字符串）。**

```python
from functools import wraps

def decorator(func):
    @wraps(func)  # 保留原函数信息
    def wrapper(*args, **kwargs):
        return func(*args, **kwargs)
    return wrapper

@decorator
def add(a, b):
    """返回两数之和"""
    return a + b

print(add.__name__)  # 输出：add（而非 wrapper）
print(add.__doc__)   # 输出：返回两数之和
```

- `@functools.lru_cache(maxsize)`：缓存函数调用结果，优化重复计算（如递归、查询）。

  

  ```python
  from functools import lru_cache
  
  @lru_cache(maxsize=None)  # 无限制缓存
  def fibonacci(n):
      if n <= 1:
          return n
      return fibonacci(n-1) + fibonacci(n-2)
  
  print(fibonacci(100))  # 快速计算，重复调用直接取缓存
  ```

- `@functools.singledispatch`：实现函数的单分派泛型（根据第一个参数类型动态选择实现）。

  

  ```python
  from functools import singledispatch
  
  @singledispatch
  def process(data):
      raise NotImplementedError("未支持的数据类型")
  
  @process.register(int)
  def _(data):
      return f"整数: {data * 2}"
  
  @process.register(str)
  def _(data):
      return f"字符串: {data.upper()}"
  
  print(process(10))    # 输出：整数: 20
  print(process("hello"))  # 输出：字符串: HELLO
  ```



#### 3. 闭包（Closures）

内层函数引用外层函数变量，形成封装的作用域：

```python
def outer(x):
    def inner(y):
        return x + y
    return inner

add5 = outer(5)
print(add5(3))  # 输出：8
```

#### 4. 迭代器与生成器函数

**`itertools` 模块**

提供了高效处理迭代器的工具函数，如：

- `itertools.chain`：拼接多个可迭代对象

  

  ```python
  import itertools
  a = [1, 2]
  b = [3, 4]
  combined = itertools.chain(a, b)
  print(list(combined))  # 输出：[1, 2, 3, 4]
  ```

- `itertools.islice`：对迭代器进行切片



与列表的 `[start:stop:step]` 切片类似，但 `islice` 直接作用于迭代器（无需先转换为列表），更节省内存（尤其对大迭代器）。
**注意**：迭代器是一次性的，`islice` 会消耗迭代器元素。

```python
import itertools

# 生成一个无限迭代器（0,1,2,3,...）
count = itertools.count(start=0, step=1)

# 从迭代器中取第2到第6个元素（左闭右开），步长为2
sliced = itertools.islice(count, 2, 6, 2)
print(list(sliced))  # 输出：[2, 4]
```

### 

- `itertools.groupby`：按 key 分组

将迭代器中相邻的、具有相同 key 的元素分组。
**注意**：分组前需先按 key 排序，否则相同 key 可能被分到不同组。



```python
import itertools

# 待分组的列表（先按key排序）
data = [('a', 1), ('a', 2), ('b', 3), ('b', 4), ('a', 5)]
data_sorted = sorted(data, key=lambda x: x[0])  # 按第一个元素排序

# 按第一个元素分组
groups = itertools.groupby(data_sorted, key=lambda x: x[0])

# 遍历分组结果
for key, group in groups:
    print(f"key: {key}, 元素: {list(group)}")
# 输出：
# key: a, 元素: [('a', 1), ('a', 2)]
# key: b, 元素: [('b', 3), ('b', 4)]
# key: a, 元素: [('a', 5)]  # 未排序的话，这里会被单独分组
```



- `itertools.product`：计算笛卡尔积

生成多个可迭代对象的所有可能组合（类似嵌套循环的结果）。

```python
import itertools

a = [1, 2]
b = ['x', 'y']

# 计算a和b的笛卡尔积
product_result = itertools.product(a, b)
print(list(product_result))  # 输出：[(1, 'x'), (1, 'y'), (2, 'x'), (2, 'y')]

# 可指定repeat参数，计算自身的多次笛卡尔积
c = [0, 1]
product_self = itertools.product(c, repeat=2)  # 等价于product(c, c)
print(list(product_self))  # 输出：[(0, 0), (0, 1), (1, 0), (1, 1)]
```



这些函数返回的都是迭代器，可直接用于循环或转换为列表，适合处理大型数据集时减少内存占用。



#### 2. 生成器表达式

轻量级迭代器，语法为 `(expr for item in iterable)`，适合惰性计算：

```python
numbers = (x** 2 for x in range(10))  # 生成器表达式
print(next(numbers))  # 输出：0
print(next(numbers))  # 输出：1
```

使用`yield`返回迭代器，节省内存：

```python
def fibonacci(n):
    a, b = 0, 1
    for _ in range(n):
        yield a
        a, b = b, a + b

for num in fibonacci(5):
    print(num)  # 0, 1, 1, 2, 3
```

### `yield` 的作用

`yield` 是 Python 中用于定义**生成器函数**的关键字，它的作用是：

- 暂停函数执行，并返回一个值（类似 `return`）。
- 下次调用生成器时，从上次暂停的位置继续执行（而不是从头开始）。

生成器的核心优势是**惰性计算**：不会一次性生成所有结果，而是按需产生，节省内存（尤其适合处理大量数据或无限序列）。



### 四、函数式编程风格特点

1. **纯函数优先**：函数输出仅由输入决定，无副作用（不修改外部状态）。

2. **不可变数据**：避免修改原有数据，而是返回新数据（如使用元组、冻结集合）。

3. 函数组合

   ：将复杂逻辑拆分为多个简单函数，通过组合实现功能。

   

   ```python
   # 函数组合示例
   def add_one(x):
       return x + 1
   
   def multiply_two(x):
       return x * 2
   
   # 组合：先加1，再乘2
   def compose(f, g):
       return lambda x: f(g(x))
   
   result = compose(multiply_two, add_one)(3)  # (3+1)*2=8
   ```

### 五、适用场景

- 数据处理与转换（如列表推导的函数式替代）
- 并行计算（纯函数无副作用，适合并发）
- 配置化逻辑（通过函数组合动态构建功能）
- 简化代码（用内置函数替代循环）

这些工具的核心价值在于**减少副作用、提高代码复用性**，并使逻辑更简洁清晰。对于复杂场景，也可结合第三方库（如 `toolz`、`fn`）增强函数式编程能力。



### 四、模块高级应用

#### 1. 模块重载

使用`importlib.reload()`重新加载已导入的模块：

```python
import importlib
import my_module
importlib.reload(my_module)  # 重新加载模块
```

#### 2. 条件导入与延迟导入

根据环境或条件导入模块，优化启动速度：

```python
if platform.system() == "Windows":
    import windows_module as os_module
else:
    import unix_module as os_module

# 延迟导入（仅在需要时导入）
def heavy_operation():
    import heavy_module
    heavy_module.do_work()
```

#### 3. 模块私有成员

以双下划线`__`开头的成员为私有，对外不可见（实际是名称修饰）：

```python
# my_module.py
def __private_func():
    return "This is private"

def public_func():
    return __private_func()
```

#### 4. 主模块判断

使用`__name__ == "__main__"`区分模块直接运行和被导入：

```python
# 当模块直接运行时执行测试代码
if __name__ == "__main__":
    test_function()  # 仅在直接运行模块时执行
```

#### 5. 分布式模块结构

大型项目中使用命名空间包、相对导入等组织代码：

```python
# 相对导入（同一包内）
from . import module1
from .subpackage import module2
```

### 五、实用技巧

1.**函数文档** **：使用文档字符串`"""`描述函数功能，可通过`help()`查看
2.** **类型提示** ：增强代码可读性和 IDE 支持

```python
def add(a: int, b: int) -> int:
    return a + b
```

3.**缓存装饰器**：`functools.lru_cache`缓存函数结果，优化性能

```python
from functools import lru_cache

@lru_cache(maxsize=None)
def factorial(n):
    return n * factorial(n-1) if n else 1
```

掌握这些知识可以帮助你编写更模块化、高效和可维护的 Python 代码，从简单脚本到大型应用都能应对自如。





   ### Python运算符（算术、关系、赋值、逻辑、位、身份、三目等）

Python 提供了丰富的运算符用于各种操作，按功能可分为以下几类：

#### 一、算术运算符

用于基本数学运算，支持整数、浮点数等数值类型。

| 运算符 | 描述               | 示例      | 结果       |
| ------ | ------------------ | --------- | ---------- |
| `+`    | 加法               | `3 + 5`   | `8`        |
| `-`    | 减法               | `10 - 4`  | `6`        |
| `*`    | 乘法               | `3 * 4`   | `12`       |
| `/`    | 除法（返回浮点数） | `10 / 3`  | `3.333...` |
| `//`   | 整除（向下取整）   | `10 // 3` | `3`        |
| `%`    | 取模（余数）       | `10 % 3`  | `1`        |
| `**`   | 幂运算             | `2 ** 3`  | `8`        |

**特殊用法**：

- `+` 可用于字符串拼接：`"Hello" + " World"` → `"Hello World"`
- `*` 可用于重复序列：`[1] * 3` → `[1, 1, 1]`

#### 二、关系运算符（比较运算符）

用于比较两个值，返回布尔值 `True` 或 `False`。

| 运算符 | 描述     | 示例     | 结果    |
| ------ | -------- | -------- | ------- |
| `==`   | 等于     | `5 == 5` | `True`  |
| `!=`   | 不等于   | `5 != 3` | `True`  |
| `>`    | 大于     | `5 > 3`  | `True`  |
| `<`    | 小于     | `5 < 3`  | `False` |
| `>=`   | 大于等于 | `5 >= 5` | `True`  |
| `<=`   | 小于等于 | `3 <= 1` | `False` |

**注意**：

- `==` 比较值是否相等，`is` 比较身份（见下文 “身份运算符”）
- 支持链式比较：`1 < 3 < 5` → `True`

#### 三、赋值运算符

用于给变量赋值，可结合算术运算符简化写法。

| 运算符 | 描述       | 示例（等价于）           |
| ------ | ---------- | ------------------------ |
| `=`    | 基础赋值   | `x = 5`                  |
| `+=`   | 加法赋值   | `x += 3` → `x = x + 3`   |
| `-=`   | 减法赋值   | `x -= 2` → `x = x - 2`   |
| `*=`   | 乘法赋值   | `x *= 4` → `x = x * 4`   |
| `/=`   | 除法赋值   | `x /= 2` → `x = x / 2`   |
| `//=`  | 整除赋值   | `x //= 3` → `x = x // 3` |
| `%=`   | 取模赋值   | `x %= 5` → `x = x % 5`   |
| `**=`  | 幂运算赋值 | `x **= 3` → `x = x** 3`  |

**多变量赋值**：

```python
a, b = 1, 2  # 同时给多个变量赋值
x = y = 10   # 链式赋值
```

#### 四、逻辑运算符

用于组合布尔表达式，返回 `True` 或 `False`。

| 运算符 | 描述                   | 示例             | 结果    |
| ------ | ---------------------- | ---------------- | ------- |
| `and`  | 逻辑与（全为真才真）   | `True and False` | `False` |
| `or`   | 逻辑或（有一个真就真） | `True or False`  | `True`  |
| `not`  | 逻辑非（取反）         | `not True`       | `False` |

**短路特性**：

- `and`：左侧为 `False` 时，右侧不执行
- `or`：左侧为 `True` 时，右侧不执行

```python
False and print("不会执行")  # 无输出
True or print("不会执行")   # 无输出
```

#### 五、位运算符

对整数的二进制位进行操作。

| 运算符                                                       | 描述                           | 示例（二进制）               | 结果（十进制） |      |      |
| ------------------------------------------------------------ | ------------------------------ | ---------------------------- | -------------- | ---- | ---- |
| `&`                                                          | 按位与（都为 1 则 1）          | `0b1010 & 0b1100` → `0b1000` | `8`            |      |      |
| `      | 按位或（有 1 则 1）            | 0b1010`0b1100→0b1110 | `14`                           |                              |                |      |      |
| `^`                                                          | 按位异或（不同则 1）           | `0b1010 ^ 0b1100` → `0b0110` | `6`            |      |      |
| `~`                                                          | 按位取反（0 变 1，1 变 0）     | `~0b1010` → `-0b1011`        | `-11`          |      |      |
| `<<`                                                         | 左移（高位丢弃，低位补 0）     | `0b1010 << 1` → `0b10100`    | `20`           |      |      |
| `>>`                                                         | 右移（低位丢弃，高位补符号位） | `0b1010 >> 1` → `0b101`      | `5`            |      |      |

**应用场景**：

- 权限控制（通过位标记表示不同权限）
- 数据压缩与加密
- 高效计算（如 `x << 1` 等价于 `x * 2`）

#### 六、身份运算符

用于判断两个对象是否为同一个（内存地址相同）。

| 运算符   | 描述           | 示例         |
| -------- | -------------- | ------------ |
| `is`     | 是同一个对象   | `a is b`     |
| `is not` | 不是同一个对象 | `a is not b` |

**与 `==` 的区别**：

- `==` 比较值是否相等
- `is` 比较内存地址是否相同（是否为同一个对象）

```python
a = [1, 2]
b = [1, 2]
print(a == b)  # True（值相等）
print(a is b)  # False（不同对象）
```

**注意**：小整数（-5 到 256）和短字符串在 Python 中会被缓存，可能导致 `is` 返回 `True`：

```python
x = 10
y = 10
print(x is y)  # True（缓存机制）
```

#### 七、成员运算符

用于判断元素是否在序列（列表、字符串、元组等）中。

| 运算符   | 描述           | 示例                       |
| -------- | -------------- | -------------------------- |
| `in`     | 元素在序列中   | `3 in [1, 2, 3]` → `True`  |
| `not in` | 元素不在序列中 | `"a" not in "bc"` → `True` |

#### 八、三目运算符（条件表达式）

简化 `if-else` 语句，格式：`表达式1 if 条件 else 表达式2`

**示例**：

```python
x = 5
result = "正数" if x > 0 else "非正数"
print(result)  # "正数"
```

**嵌套使用**：

```python
score = 85
grade = "优秀" if score >= 90 else "良好" if score >= 80 else "及格"
print(grade)  # "良好"
```

#### 九、运算符优先级（简化版）

从高到低排序（可通过括号 `()` 改变优先级）：

1. 幂运算 `**`
2. 正负号 `+x`、`-x`
3. 算术运算符（`*`、`/`、`//`、`%` 高于 `+`、`-`）
4. 位运算符（`~` 高于 `<<`、`>>` 高于 `&` 高于 `^` 高于 `|`）
5. 关系运算符（`==`、`!=`、`>`、`<` 等）
6. 身份运算符（`is`、`is not`）
7. 成员运算符（`in`、`not in`）
8. 逻辑非 `not`
9. 逻辑与 `and`
10. 逻辑或 `or`

**示例**：

```python
print(2 + 3 * 4)  # 14（乘法优先于加法）
print((2 + 3) * 4)  # 20（括号改变优先级）
```

掌握这些运算符及其优先级，能帮助你写出简洁、高效的代码，避免因运算顺序导致的逻辑错误。



### Python流程控制之if判断

在 Python 中，`if` 语句是最基础的流程控制结构之一，用于根据条件判断执行不同的代码块。它允许程序根据特定条件动态选择执行路径，是实现分支逻辑的核心工具。

#### 一、基本语法

`if` 语句的基本结构由 `if`、可选的 `elif`（else if）和 `else` 组成，语法如下：

```python
if 条件表达式1:
    # 条件1为True时执行的代码块
    语句1
elif 条件表达式2:
    # 条件1为False且条件2为True时执行的代码块
    语句2
elif 条件表达式3:
    # 前序条件都为False且条件3为True时执行的代码块
    语句3
else:
    # 所有条件都为False时执行的代码块
    语句4
```

**关键点**：

- 条件表达式的结果必须是布尔值（`True` 或 `False`）
- 代码块必须通过缩进（通常是 4 个空格）区分，缩进是 Python 语法的一部分
- `elif` 和 `else` 都是可选的，可根据需求组合使用

#### 二、单分支判断（仅 if）

当只需要在条件满足时执行某些操作，不满足时不做处理，可使用单独的 `if` 语句：

```python
age = 18
if age >= 18:
    print("已成年，可独立办理业务")

# 输出：已成年，可独立办理业务
```

如果条件不成立，则代码块不执行：

```python
age = 16
if age >= 18:
    print("已成年")  # 条件不成立，此句不执行
```

#### 三、双分支判断（if-else）

当需要根据条件二选一执行时，使用 `if-else` 结构：

```python
score = 85
if score >= 60:
    print("考试通过")
else:
    print("考试未通过")

# 输出：考试通过
```

**应用场景**：二选一的逻辑，如 “登录成功 / 失败”“数据存在 / 不存在” 等。

#### 四、多分支判断（if-elif-else）

当需要判断多个条件时，使用 `if-elif-else` 结构，程序会依次检查条件，执行第一个满足的分支：

```python
score = 85
if score >= 90:
    print("优秀")
elif score >= 80:
    print("良好")
elif score >= 60:
    print("及格")
else:
    print("不及格")

# 输出：良好
```

**注意**：

- 条件判断是 “短路” 的，一旦某个条件成立，后续条件不再检查
- 条件顺序很重要，需从严格到宽松排列（如先判断 90 分以上，再判断 80 分以上）

#### 五、条件表达式的类型

`if` 后的条件表达式不仅可以是比较运算，还可以是任何返回布尔值的表达式：

1. **比较运算**（最常用）：

   ```python
   x = 10
   if x > 5 and x < 15:  # 逻辑运算符组合条件
       print("x在5到15之间")
   ```

2. **成员判断**（`in`/`not in`）：

   ```python
   fruits = ["apple", "banana"]
   if "apple" in fruits:
       print("苹果在列表中")
   ```

3. **身份判断**（`is`/`is not`）：

   ```python
   a = None
   if a is None:
       print("变量a未赋值")
   ```

4. **真值判断**（利用 Python 中 “假值” 的特性）：
   Python 中以下值被视为 `False`：`None`、`0`、`""`、`[]`、`{}`、`()` 等空对象。

   ```python
   name = ""
   if not name:  # 空字符串视为False，not后变为True
       print("请输入姓名")
   ```

#### 六、嵌套 if 语句

`if` 语句内部可以嵌套另一个 `if` 语句，用于处理更复杂的多层条件判断：

```python
age = 20
has_id = True

if age >= 18:
    print("已成年")
    if has_id:
        print("可进入网吧")
    else:
        print("请出示身份证")
else:
    print("未成年，禁止进入")

# 输出：
# 已成年
# 可进入网吧
```

**注意**：嵌套层次越多，代码可读性越差，建议尽量控制嵌套层数（通常不超过 3 层）。

#### 七、常见用法与技巧

1. **多条件并列**：
   使用逻辑运算符 `and`（且）、`or`（或）组合多个条件：

   

   ```python
   # 判断年份是否为闰年（能被4整除且不能被100整除，或能被400整除）
   year = 2020
   if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0):
       print(f"{year}是闰年")
   ```

2. **与三目运算符结合**：
   简单的 `if-else` 可简化为三目表达式：

   ```python
   # 等价于 if-else 结构
   result = "通过" if score >= 60 else "未通过"
   ```

3. **提前退出（卫语句）**：
   对于复杂条件，可先判断 “不满足条件” 的情况并提前退出，减少嵌套：

   ```python
   def calculate(a, b):
       if b == 0:  # 提前判断异常情况
           print("除数不能为0")
           return
       # 正常逻辑（无需嵌套）
       print(a / b)
   ```

#### 八、常见错误

1. **缩进错误**：忘记缩进或缩进不一致会导致 `IndentationError`
2. **条件后缺少冒号**：`if`、`elif`、`else` 后必须加冒号 `:`
3. **误用 `=` 代替 `==`**：`if x = 5` 是赋值而非判断，会导致语法错误
4. **条件顺序错误**：如先判断 `score >= 60` 再判断 `score >= 90`，会导致高分条件永远不触发

`if` 语句是 Python 中实现分支逻辑的基础，掌握其用法能让程序根据不同情况做出灵活响应。在实际开发中，合理组织条件判断的结构，能显著提高代码的可读性和可维护性。



   ### Python流程控制之循环语句（While循环&For循环） 

在 Python 中，循环语句用于重复执行一段代码，是实现 “批量处理”“迭代遍历” 等逻辑的核心工具。主要分为 **`while` 循环**（基于条件重复）和 **`for` 循环**（基于可迭代对象遍历），两者适用场景不同，但都支持灵活的流程控制（如 `break`、`continue`）。

#### 一、`while` 循环：基于条件的重复

`while` 循环的核心逻辑是：**只要条件表达式为 `True`，就持续执行循环体**，直到条件变为 `False` 时退出。

**1. 基本语法**

```python
while 条件表达式:
    # 循环体（缩进代码块）
    语句1
    语句2
    # （可选）更新条件的语句（避免死循环）
```

**执行流程**：

1. 判断 `条件表达式` 的值（`True`/`False`）。
2. 若为 `True`，执行循环体；若为 `False`，退出循环，执行后续代码。
3. 循环体执行完毕后，回到步骤 1，重新判断条件（直到条件为 `False`）。

#### 2. 典型示例

##### 示例 1：基本计数循环（从 1 到 5）

```python
count = 1  # 初始化计数器
while count <= 5:  # 条件：count不超过5
    print(f"当前计数：{count}")
    count += 1  # 更新计数器（关键：避免死循环）

# 输出：
# 当前计数：1
# 当前计数：2
# 当前计数：3
# 当前计数：4
# 当前计数：5
```

##### 示例 2：用户输入验证（直到输入正确）

```python
password = ""
while password != "123456":  # 条件：密码不正确则重复
    password = input("请输入密码：")
print("密码正确，登录成功！")

# 执行过程：
# 若输入错误（如"abc"），会反复提示输入；直到输入"123456"，退出循环。
```

#### 3. 注意：避免死循环

`while` 循环的最大风险是**死循环**（条件永远为 `True`，循环永不退出），需确保循环体内有 “更新条件” 的逻辑：

```python
# 错误示例：死循环（count始终为1，条件永远True）
count = 1
while count <= 5:
    print(count)
    # 缺少 count += 1，导致无限循环

# 正确示例：通过用户输入控制退出
while True:  # 条件恒为True，需手动控制退出
    user_input = input("输入'q'退出：")
    if user_input == "q":
        break  # 用break强制退出循环
    print(f"你输入的是：{user_input}")
```

#### 二、`for` 循环：基于可迭代对象的遍历

`for` 循环的核心逻辑是：**遍历 “可迭代对象”（如列表、字符串、元组等）中的每个元素，执行一次循环体**，元素遍历完毕后自动退出。

Python 的 `for` 循环与其他语言（如 C/C++）的 “计数式 `for` 循环” 不同，更强调 “迭代遍历”，语法更简洁。

**1. 基本语法**

```python
for 变量名 in 可迭代对象:
    # 循环体：变量名依次代表可迭代对象的每个元素
    语句1
    语句2
```

**可迭代对象**：指能被 `for` 循环遍历的对象，常见类型包括：

- 序列：列表（`list`）、字符串（`str`）、元组（`tuple`）
- 集合：集合（`set`）、字典（`dict`，默认遍历键）
- 生成器：`range()`、生成器表达式等

**2. 典型示例**

##### 示例 1：遍历列表（批量处理元素）

```python
fruits = ["apple", "banana", "orange"]
for fruit in fruits:  # fruit依次代表列表中的每个元素
    print(f"我喜欢吃：{fruit}")

# 输出：
# 我喜欢吃：apple
# 我喜欢吃：banana
# 我喜欢吃：orange
```

##### 示例 2：遍历字符串（逐个字符）

```python
text = "Python"
for char in text:  # char依次代表字符串的每个字符
    print(f"字符：{char}")

# 输出：
# 字符：P
# 字符：y
# 字符：t
# 字符：h
# 字符：o
# 字符：n
```

##### 示例 3：遍历字典（键、值、键值对）

字典默认遍历 “键”，可通过 `keys()`、`values()`、`items()` 分别遍历键、值、键值对：

```python
student = {"name": "Alice", "age": 18, "grade": "A"}

# 遍历键（默认）
for key in student:
    print(f"键：{key}")

# 遍历值
for value in student.values():
    print(f"值：{value}")

# 遍历键值对（用元组解包）
for key, value in student.items():
    print(f"{key}: {value}")
```

##### 示例 4：`range()` 生成数字序列（模拟计数循环）

**`range()`** 是 Python 内置函数，生成一个 “不可见的数字序列”，常用于 `for` 循环的计数场景：

- `range(n)`：生成 `0 ~ n-1` 的整数（如 `range(3)` → 0,1,2）
- `range(start, end)`：生成 `start ~ end-1` 的整数（如 `range(1,4)` → 1,2,3）
- `range(start, end, step)`：指定步长（如 `range(1,10,2)` → 1,3,5,7,9）

```python
# 示例：计算1~10的和
total = 0
for num in range(1, 11):  # 1到10（end=11，所以包含10）
    total += num
print(f"1~10的和：{total}")  # 输出：55
```

#### 三、循环控制：`break` 与 `continue`

`break` 和 `continue` 是用于 “精细控制循环流程” 的关键字，可在循环体内根据条件调整执行逻辑。

**1. `break`：强制退出循环**

`break` 会**立即终止当前循环**，跳出循环体，执行循环后的代码（无论循环条件是否满足）。

**示例：查找列表中的目标元素**

```python
numbers = [10, 20, 30, 40, 50]
target = 30

for num in numbers:
    if num == target:
        print(f"找到目标：{num}")
        break  # 找到后立即退出循环，不再遍历后续元素
    print(f"当前元素：{num}")

# 输出：
# 当前元素：10
# 当前元素：20
# 找到目标：30
# （40、50未被遍历）
```

2. **`continue`：跳过当前迭代，进入下一次**

`continue` 会**跳过当前循环体的剩余代码**，直接回到循环开头，判断下一次迭代是否执行（不终止整个循环）。

**示例：打印 1~10 中的奇数**

```python
for num in range(1, 11):
    if num % 2 == 0:  # 若为偶数，跳过后续打印
        continue
    print(f"奇数：{num}")  # 仅奇数会执行此句

# 输出：
# 奇数：1
# 奇数：3
# 奇数：5
# 奇数：7
# 奇数：9
```

**3. `break` 与 `continue` 的区别**

| 关键字     | 作用         | 对循环的影响                   |
| ---------- | ------------ | ------------------------------ |
| `break`    | 强制退出     | 终止整个循环，不再执行后续迭代 |
| `continue` | 跳过当前迭代 | 仅跳过当前次，继续下一次迭代   |

##### 四、嵌套循环

循环内部可以嵌套另一个循环（`while` 或 `for` 均可），用于处理 “多层结构” 的数据（如二维列表、矩阵等）。

**示例：打印九九乘法表（`for` 嵌套）**

```python
# 外层循环控制行数（1~9）
for i in range(1, 10):
    # 内层循环控制每行的列数（1~i）
    for j in range(1, i+1):
        print(f"{j}×{i}={i*j}", end="\t")  # end="\t" 用制表符分隔
    print()  # 每行结束后换行

# 输出：
# 1×1=1	
# 1×2=2	2×2=4	
# 1×3=3	2×3=6	3×3=9	
# ...（直到9×9=81）
```

**注意**：嵌套循环的执行效率会随层数增加而降低，建议尽量控制嵌套层数（通常不超过 3 层）。

##### 五、`while` 循环 vs `for` 循环：适用场景对比

| 循环类型 | 核心逻辑                               | 适用场景                                                     | 优点                                       |
| -------- | -------------------------------------- | ------------------------------------------------------------ | ------------------------------------------ |
| `while`  | 基于条件重复，条件为 `True` 则执行     | 1. 循环次数不确定（如用户输入验证） 2. 需手动控制循环变量（如自定义计数逻辑） | 灵活性高，可处理动态条件                   |
| `for`    | 基于可迭代对象遍历，次数由对象长度决定 | 1. 遍历已知序列（如列表、字符串） 2. 循环次数固定（如 `range(10)`） 3. 批量处理元素（如字典键值对） | 语法简洁，无需手动管理循环变量，不易死循环 |

##### 六、常见错误与注意事项

1. **`while` 循环的死循环**：忘记更新循环条件（如 `count` 未递增），导致条件永远为 `True`。
2. **`for` 循环修改可迭代对象**：遍历列表时直接修改列表（如 `del` 或 `append`），可能导致遍历异常（建议遍历副本，如 `for x in list.copy()`）。
3. **缩进错误**：循环体必须缩进（4 个空格），否则会报 `IndentationError`，或导致代码逻辑错误（如循环体外的代码被误判为循环内）。
4. **`range()` 的边界问题**：`range(start, end)` 包含 `start` 但不包含 `end`，需注意边界值（如 `range(1,5)` 是 1,2,3,4，而非 5）。

##### 总结

- **`while` 循环**：适合 “条件驱动” 的重复场景，需手动控制循环变量和退出条件。
- **`for` 循环**：适合 “遍历驱动” 的场景，尤其对序列、集合等可迭代对象，语法更简洁高效。
- **循环控制**：`break` 终止循环，`continue` 跳过当前迭代，可灵活调整执行逻辑。

掌握两种循环的用法和适用场景，能高效实现批量处理、数据遍历等核心需求，是编写 Python 程序的基础技能。



### Python流程控制之 **`try-except`**

`try-except` 是 Python 中用于异常处理的核心结构，它允许程序在运行时捕获并处理错误，而不是直接崩溃。这种机制能显著提高程序的健壮性，尤其常用于处理不可预见的情况（如用户输入错误、文件操作失败等）。

#### 一、基本语法结构

`try-except` 的基本框架如下：

```python
try:
    # 可能发生异常的代码块（尝试执行）
    危险操作
except 异常类型1:
    # 当发生“异常类型1”时执行的代码
    处理方式1
except 异常类型2:
    # 当发生“异常类型2”时执行的代码
    处理方式2
else:
    # 当 try 块无异常常时执行的代码（可选）
    正常逻辑
finally:
    # 无论是否发生异常，都会执行的代码（可选）
    清理操作
```

**执行流程**：

1. 执行 `try` 块中的代码。
2. 如果发生异常，立即跳转到对应的 `except` 块处理。
3. 如果无异常，执行 `else` 块（若有）。
4. 最后一定会执行 `finally` 块（若有）。

#### 二、核心组件解析

1. **`try` 块**

- 包含可能引发异常的代码（如文件操作、网络请求、数据转换等）。
- 一旦某行代码引发异常，后续代码不再执行，直接进入异常处理流程。

```python
try:
    print("尝试转换数字...")
    num = int("abc")  # 这里会引发 ValueError
    print("转换成功")  # 此行不会执行（因为上一行已出错）
```

2. **`except` 块：捕获指定异常**

`except` 用于捕获特定类型的异常，并定义处理逻辑。

- **捕获单一异常**：

  ```python
  try:
      num = int("abc")
  except ValueError:  # 只处理 ValueError 类型的异常
      print("转换失败：输入不是有效数字")
  ```

- **捕获多个异常**：
  可以用元组指定多种异常类型，共用同一种处理逻辑：

  

  ```python
  try:
      result = 10 / 0  # 可能引发 ZeroDivisionError
      # 或 num = int("abc")  # 可能引发 ValueError
  except (ZeroDivisionError, ValueError) as e:  # 用 as e 获取异常对象
      print(f"发生错误：{e}")  # 打印错误详情
  ```

- **捕获所有异常**（不推荐）：
  用 `except Exception` 可捕获几乎所有非系统退出的异常，但可能掩盖未知错误：

  ```python
  try:
      risky_operation()
  except Exception as e:  # 捕获所有常规异常
      print(f"发生未知错误：{e}")
  ```

  **注意**：永远不要用空的 `except` 块（`except:`），这会隐藏所有错误，包括键盘中断（`Ctrl+C`）。

3. **`else` 块（可选）**

当 `try` 块**没有发生任何异常**时执行，用于分离 “正常逻辑” 和 “异常处理逻辑”：

```python
try:
    num = int(input("请输入数字："))
except ValueError:
    print("输入错误")
else:
    # 只有转换成功时才执行
    print(f"你输入的数字是：{num}")
```

**4. `finally` 块（可选）**

无论是否发生异常，**一定会执行**的代码块，常用于资源清理（如关闭文件、释放连接等）：

```python
file = None
try:
    file = open("data.txt", "r")
    content = file.read()
except FileNotFoundError:
    print("文件不存在")
finally:
    # 确保文件无论如何都会关闭
    if file:
        file.close()
        print("文件已关闭")
```

**现代替代方案**：对于文件、网络连接等资源，更推荐用 `with` 语句（自动管理资源），但 `finally` 仍适用于其他场景。

#### 三、异常的传递性

如果异常在当前 `try-except` 中未被捕获，会向上层调用栈传递，直到被捕获或导致程序终止：

```python
def func1():
    func2()  # 调用 func2，可能传递异常

def func2():
    num = int("abc")  # 引发 ValueError

try:
    func1()  # 调用链的顶层
except ValueError:
    print("在顶层捕获到异常")  # 会执行此句
```

#### 四、主动引发异常（`raise`）

除了捕获系统自动引发的异常，也可以用 `raise` 主动抛出异常，用于验证输入或标记错误状态：

```python
def withdraw(amount):
    if amount < 0:
        # 主动引发 ValueError，并附带错误信息
        raise ValueError("取款金额不能为负数")
    print(f"取款 {amount} 元成功")

try:
    withdraw(-100)
except ValueError as e:
    print(f"操作失败：{e}")  # 输出：操作失败：取款金额不能为负数
```

#### 五、常见异常类型

Python 内置了多种异常类型，常见的有：

- `ValueError`：值无效（如 `int("abc")`）
- `TypeError`：类型错误（如 `"2" + 2`）
- `ZeroDivisionError`：除零错误
- `FileNotFoundError`：文件不存在
- `PermissionError`：权限不足
- `IndexError`：列表索引越界
- `KeyError`：字典键不存在
- `AttributeError`：对象属性不存在

可以通过官方文档查看完整的异常层级结构。

#### 六、最佳实践

1. **捕获具体异常**：避免用 `except Exception` 捕获所有异常，应针对性处理已知错误。
2. **提供有用信息**：在异常处理中说明错误原因，便于调试（如 `print(f"错误：{e}")`）。
3. **清理资源优先**：用 `finally` 或 `with` 语句确保资源（文件、网络连接等）被正确释放。
4. **不滥用异常**：简单的条件判断（如 `if x < 0`）比 `try-except` 更高效，不应替代 `if` 使用。
5. **避免空 `except` 块**：至少打印错误信息，否则难以排查问题。

#### 示例：综合应用

```python
def process_data(input_str):
    try:
        # 尝试转换为整数
        num = int(input_str)
    except ValueError as e:
        print(f"数据转换失败：{e}")
        return None  # 转换失败返回 None
    else:
        # 转换成功则处理数据
        result = num * 2
        print(f"处理后的数据：{result}")
        return result
    finally:
        # 无论成功失败，都记录日志
        print(f"处理结束，输入内容：{input_str}")

# 测试
process_data("10")   # 正常情况
process_data("abc")  # 异常情况
```

输出：

```plaintext
处理后的数据：20
处理结束，输入内容：10
数据转换失败：invalid literal for int() with base 10: 'abc'
处理结束，输入内容：abc
```

`try-except` 是编写健壮 Python 程序的必备工具，它让程序在面对错误时能优雅处理，而不是直接崩溃。合理使用异常处理，能显著提升代码的可靠性和用户体验。



## Python：函数和类

在 Python 中，**函数（Function）** 和**类（Class）** 是组织代码的核心工具，分别对应**函数式编程**和**面向对象编程**两种主流范式。理解它们的设计目的、核心特性和适用场景，是掌握 Python 编程的基础。以下从整体框架到细节特性进行系统介绍：

### 一、整体认知：代码组织的两种核心范式

编程的本质是 “用代码解决问题”，而函数和类是两种不同的代码组织方式：

- **函数式编程 **：用**函数 **封装独立功能，通过函数调用和参数传递实现逻辑（强调 “过程和操作”）。
- **面向对象编程（OOP**：用**类 ** 封装数据和操作数据的方法，通过 “对象”（类的实例）交互实现逻辑（强调 “实体和关系”）。

举个生活例子：

- 函数像 “工具”（如 “计算器”），输入参数（如两个数字），输出结果（如和），专注于 “做什么”。
- 类像 “模板”（如 “汽车模板”），包含属性（如颜色、排量）和方法（如启动、刹车），实例化后的 “对象”（如一辆具体的车）既有数据又有行为，专注于 “是什么” 和 “能做什么”。

### 二、函数（Function）：封装独立功能的代码块

函数是**一段实现特定功能的可重用代码**，通过函数名调用，可接收输入（参数）并返回输出（结果）。

#### 1. 函数的基础：定义与调用

用 `def` 关键字定义函数，基本语法：

```python
def 函数名(参数列表):
    """文档字符串（描述函数功能、参数、返回值）"""
    # 函数体（实现功能的代码）
    return 返回值  # 可选，无return则默认返回None
```

**示例**：定义一个计算面积的函数

```python
def calculate_area(radius):
    """计算圆的面积
    参数：
        radius: 圆的半径（正数）
    返回：
        圆的面积（π×radius²）
    """
    if radius <= 0:
        return 0  # 无效半径返回0
    return 3.14 * radius** 2

# 调用函数：传入参数，获取返回值
area = calculate_area(5)
print(area)  # 输出：78.5
```

#### 2. 函数的核心特性：参数与返回值

函数的灵活性主要体现在参数传递和返回值处理上。

##### （1）参数类型：适配不同调用场景

- **必选参数**：必须传递的参数，按位置匹配。

  ```python
  def subtract(a, b):  # a和b是必选参数
      return a - b
  subtract(10, 3)  # 输出：7（a=10, b=3）
  ```

- **默认参数**：定义时指定默认值，调用时可省略（简化常见场景）。

  ```python
  def power(base, exp=2):  # exp默认值为2（平方）
      return base **exp
  power(3)  # 省略exp，用默认值 → 3²=9
  power(3, 3)  # 传递exp=3 → 3³=27
  ```

- **关键字参数**：调用时用 `参数名=值` 传递，可打乱顺序（增强可读性）。

```python
def greet(name, message):
    return f"{message}, {name}!"
greet(message="Hello", name="Alice")  # 顺序无关 → "Hello, Alice!"
```

- **不定长参数 **：接收任意数量的参数（参数数量不确定时使用）。

- `*args`：收集所有位置参数为元组。
- `**kwargs`：收集所有关键字参数为字典。

```python
def print_info(*args, **kwargs):
    print("位置参数：", args)    # 元组形式
    print("关键字参数：", kwargs)  # 字典形式

print_info(1, 2, name="Bob", age=20)
# 输出：
# 位置参数： (1, 2)
# 关键字参数： {'name': 'Bob', 'age': 20}
```

##### （2）返回值：函数执行的结果

- 可返回单个值、多个值（自动打包为元组），或无返回值（默认返回none

  

  ```python
  def divide(a, b):
      quotient = a // b    # 商
      remainder = a % b    # 余数
      return quotient, remainder  # 返回多个值（元组）
  
  q, r = divide(10, 3)  # 解包返回值
  print(f"商：{q}，余数：{r}")  # 输出：商：3，余数：1
  ```

#### 3. 函数的作用域：变量的可见范围

函数内部的变量与外部变量相互隔离，避免命名冲突：

- **局部变量 **：函数内定义的变量，仅在函数内有效（函数执行结束后销毁）
- **全局变量 **：函数外定义的变量，可在函数内访问（需用 `global` 声明才能修改）。
- **非局部变量 **：嵌套函数中，内部函数修改外部函数的变量需用 `nonlocal` 声明。

```python
x = 10  # 全局变量

def outer():
    y = 20  # 外部函数的局部变量
    def inner():
        nonlocal y  # 声明修改外部函数的变量
        y = 200
        global x    # 声明修改全局变量
        x = 100
    inner()
    print(y)  # 输出：200（被inner修改）

outer()
print(x)  # 输出：100（被inner修改）
```

#### 4. 特殊函数类型：扩展函数的能力

- **匿名函数（lambda）**：用 `lambda` 定义的单行短函数，无名称，适用于简单逻辑（作为参数传递时常用）。

```python
# 等价于 def add(x,y): return x+y
add = lambda x, y: x + y
print(add(2, 3))  # 输出：5

# 作为sorted的排序键
students = [("Alice", 20), ("Bob", 18)]
sorted_students = sorted(students, key=lambda s: s[1])  # 按年龄排序
```

-**递归函数 **：函数调用自身，用于分治问题（将复杂问题分解为同类子问题）。

```python
def factorial(n):
    if n == 1:  # 基线条件（终止递归）
        return 1
    return n * factorial(n-1)  # 递归调用（n! = n × (n-1)!）

print(factorial(5))  # 输出：120（5×4×3×2×1）
```

- **生成器函数 **：用 `yield` 关键字返回迭代器，惰性生成数据（节省内存，适合大数据场景）。

```python
def generate_even_numbers(n):
    for i in range(n):
        if i % 2 == 0:
            yield i  # 每次返回一个偶数，暂停执行

# 迭代生成器（逐个获取值）
for num in generate_even_numbers(10):
    print(num, end=" ")  # 输出：0 2 4 6 8
```

- **高阶函数 **：接收函数作为参数，或返回函数（实现函数的灵活组合）。

```python
def apply(func, x, y):
    """接收函数作为参数并调用"""
    return func(x, y)

# 传递lambda函数作为参数
print(apply(lambda a, b: a * b, 3, 4))  # 输出：12
```

### 三、类（Class）：面向对象的核心载体

类是**描述 “对象” 共同属性和行为的模板**，而 “对象” 是类的具体实例。面向对象编程通过类和对象实现 “封装、继承、多态” 三大特性，更适合描述复杂实体（如 “用户”“订单”“汽车”）。

#### 1. 类的基础：定义与实例化

用 `class` 关键字定义类，通过类创建对象（实例化）：

```python
class 类名:
    # 类属性（所有实例共享的变量）
    类变量 = 值
    
    def __init__(self, 参数):  # 构造方法（初始化对象）
        # 实例属性（每个实例独有的变量，用self.xxx定义）
        self.实例变量1 = 参数1
        self.实例变量2 = 参数2
    
    def 方法名(self, 参数):  # 实例方法（操作实例的行为）
        # 方法体（可访问self.实例变量）
        return 结果
```

**示例**：定义一个 “学生” 类并创建对象

```python
class Student:
    # 类属性：所有学生共享的学校名称
    school = "阳光中学"
    
    # 构造方法：初始化学生的姓名和年龄
    def __init__(self, name, age):
        self.name = name  # 实例属性：姓名（每个学生不同）
        self.age = age    # 实例属性：年龄（每个学生不同）
    
    # 实例方法：学生打招呼
    def greet(self):
        return f"大家好，我是{self.name}，今年{self.age}岁，来自{self.school}。"

# 实例化：创建两个Student对象（具体学生）
student1 = Student("小明", 15)
student2 = Student("小红", 14)

# 访问对象的属性和方法
print(student1.name)       # 输出：小明（实例属性）
print(student1.school)     # 输出：阳光中学（类属性）
print(student1.greet())    # 输出：大家好，我是小明，今年15岁，来自阳光中学。
```

#### 2. 面向对象的三大特性

##### （1）封装：隐藏内部细节，暴露安全接口

将数据（属性）和操作数据的方法捆绑在类中，通过 “访问控制” 保护数据（Python 用命名规范实现）：

- 公开属性 / 方法：直接访问（如 `self.name`）。
- 私有属性 / 方法：用 `_` 或 `__` 前缀（约定不直接访问，通过公开方法操作）。

```python
class BankAccount:
    def __init__(self, balance):
        self.__balance = balance  # 私有属性（双下划线，强制隐藏）
    
    # 公开方法：安全操作私有属性
    def deposit(self, amount):
        if amount > 0:
            self.__balance += amount
    
    def get_balance(self):
        return self.__balance

account = BankAccount(1000)
account.deposit(500)
print(account.get_balance())  # 输出：1500
# print(account.__balance)  # 报错：无法直接访问私有属性
```

##### （2）继承：复用代码，扩展功能

子类（派生类）继承父类（基类）的属性和方法，并可添加新属性 / 方法或重写父类方法（避免重复代码）。

```python
# 父类：Person
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age
    
    def greet(self):
        return f"我是{self.name}，{self.age}岁。"

# 子类：Student（继承Person）
class Student(Person):
    def __init__(self, name, age, grade):
        # 调用父类的构造方法（复用初始化逻辑）
        super().__init__(name, age)
        self.grade = grade  # 新增属性：年级
    
    # 重写父类的greet方法（扩展功能）
    def greet(self):
        return f"我是{self.name}，{self.age}岁，读{self.grade}年级。"

student = Student("小李", 13, 7)
print(student.greet())  # 输出：我是小李，13岁，读7年级。（调用重写后的方法）
```

##### （3）多态：同一接口，不同实现

不同类的对象调用同名方法时，表现出不同行为（通过方法重写实现），提高代码灵活性。

```python
# 定义一个通用函数（接收Person或其子类对象）
def introduce(person):
    print(person.greet())  # 调用greet()，行为取决于对象类型

p = Person("老王", 40)
s = Student("小张", 16, 10)

introduce(p)  # 输出：我是老王，40岁。（调用Person的greet）
introduce(s)  # 输出：我是小张，16岁，读10年级。（调用Student的greet）
```

#### 3. 类的特殊成员

- **特殊方法（魔术方法）**：以 `__` 开头和结尾，用于实现类的特殊行为（如初始化、字符串表示、运算符重载）。

  

  ```python
  class Book:
      def __init__(self, title, price):
          self.title = title
          self.price = price
      
      def __str__(self):  # 打印对象时调用（友好显示）
          return f"《{self.title}》，价格：{self.price}元"
      
      def __add__(self, other):  # 重载+运算符
          return self.price + other.price
  
  book1 = Book("Python入门", 50)
  book2 = Book("Python进阶", 70)
  
  print(book1)        # 输出：《Python入门》，价格：50元（调用__str__）
  print(book1 + book2)  # 输出：120（调用__add__）
  ```

- **类方法与静态方法**：

  - **类方法（`@classmethod`）**：操作类属性，第一个参数为 `cls`（代表类本身）。
  - **静态方法（`@staticmethod`）**：与类和实例无关，无默认参数（类似独立函数，只是放在类中组织）。

  ```python
  class MathUtil:
      pi = 3.14  # 类属性：圆周率
      
      @classmethod
      def circle_area(cls, radius):  # 类方法：用cls访问类属性
          return cls.pi * radius **2
      
      @staticmethod
      def add(a, b):  # 静态方法：与类属性无关
          return a + b
  
  # 调用类方法（无需创建对象）
  print(MathUtil.circle_area(2))  # 输出：12.56
  # 调用静态方法
  print(MathUtil.add(2, 3))      # 输出：5
  ```

这段代码展示了 Python 中类的两种特殊方法：**类方法（`@classmethod`）** 和 **静态方法（`@staticmethod`）**，它们与普通的实例方法（`def method(self):`）在功能和使用场景上有显著区别。以下是详细解析：

##### 一、类方法（`@classmethod`）

类方法是**与类本身绑定的方法**，而非与类的实例绑定。它的核心特点是：

**1. 定义与参数**

- 用 **`@classmethod`** 装饰器声明。
- 第一个参数必须是 `cls`（约定俗成的名称，代表类本身，类似实例方法的 `self`）。
- 通过 `cls` 可以访问和修改**类属性**（所有实例共享的属性），但不能直接访问实例属性（需通过实例对象）。

**2. 代码解析（`circle_area` 方法）**

```python
class MathUtil:
    pi = 3.14  # 类属性（所有实例共享）
    
    @classmethod
    def circle_area(cls, radius):
        # 通过 cls 访问类属性 pi
        return cls.pi * radius **2
```

- **调用方式 **：可通过类名直接调用（无需创建实例），也可通过实例调用：

```python
# 类名直接调用（推荐）
print(MathUtil.circle_area(2))  # 输出：12.56（3.14 × 2²）

# 实例调用（也可行，但逻辑上没必要创建实例）
mu = MathUtil()
print(mu.circle_area(2))  # 输出：12.56
```

- **核心作用 **：操作类属性或实现与类相关的逻辑（如创建 “替代构造函数”）。
  例如，扩展一个根据直径计算面积的类方法：

```python
@classmethod
def circle_area_by_diameter(cls, diameter):
    radius = diameter / 2
    return cls.circle_area(radius)  # 调用同类的其他类方法

MathUtil.circle_area_by_diameter(4)  # 直径4 → 半径2 → 面积12.56
```

##### 二、静态方法（`@staticmethod`）

静态方法是**定义在类中的普通函数**，它与类和实例都没有绑定关系。核心特点是：

**1. 定义与参数**

- 用 `@staticmethod` 装饰器声明。
- 没有默认参数（既不需要 `self`，也不需要 `cls`）。
- 不能直接访问类属性或实例属性（除非通过参数传递类或实例对象）。

**2. 代码解析（`add` 方法）**

```python
class MathUtil:
    @staticmethod
    def add(a, b):
        # 仅依赖输入参数，与类属性/实例属性无关
        return a + b
```

- **调用方式 **：同样可通过类名或实例调用，但逻辑上与类无关：

```python
# 类名调用（推荐）
print(MathUtil.add(2, 3))  # 输出：5

# 实例调用（可行，但无意义）
mu = MathUtil()
print(mu.add(2, 3))  # 输出：5
```

- **核心作用 **：封装与类相关但不依赖类状态的工具逻辑（相当于 “放在类里的普通函数”，仅为了代码组织）。
  例如，添加一个判断数字是否为偶数的静态方法：

```python
@staticmethod
def is_even(num):
    return num % 2 == 0

MathUtil.is_even(4)  # 输出：True
```

##### 三、类方法 vs 静态方法 vs 实例方法

为了更清晰区分，对比三种方法的核心差异：

| 方法类型 | 装饰器          | 第一个参数 | 可访问的属性                   | 典型用途                             |
| -------- | --------------- | ---------- | ------------------------------ | ------------------------------------ |
| 实例方法 | 无              | `self`     | 实例属性、类属性               | 操作实例状态（如 `student.greet()`） |
| 类方法   | `@classmethod`  | `cls`      | 类属性（不能直接访问实例属性） | 操作类状态、替代构造函数             |
| 静态方法 | `@staticmethod` | 无         | 无（需显式传递参数）           | 工具函数（与类相关但无状态依赖）     |

##### 四、典型应用场景

1.**类方法的典型场景 **：

- 访问 / 修改类属性（如 `circle_area` 中使用 `cls.pi`）。

- 实现 “替代构造函数”（通过不同参数创建实例）：

  ```python
  class Date:
      def __init__(self, year, month, day):
          self.year = year
          self.month = month
          self.day = day
      
      @classmethod
      def from_string(cls, date_str):  # 从字符串创建日期（如 "2023-10-01"）
          year, month, day = map(int, date_str.split("-"))
          return cls(year, month, day)  # 返回新实例
  
  date = Date.from_string("2023-10-01")  # 替代构造函数
  ```

2.**静态方法的典型场景 **：

- 封装与类相关的工具函数（如数学计算、数据验证）。

- 避免创建独立的工具模块，将相关函数组织在类中：

  ```python
  class StringUtil:
      @staticmethod
      def is_email(s):  # 验证邮箱格式（与类状态无关）
          return "@" in s and "." in s
  ```

##### 总结

- **类方法（`@classmethod`）**：依赖类本身（通过 `cls` 访问类属性），用于类级别的操作。

- **静态方法（`@staticmethod`）**：与类和实例均无关，仅为代码组织而放在类中，功能上等价于独立函数。

**选择原则：**

- 需要访问类属性 → 用类方法。
- 不需要访问类 / 实例属性，但逻辑上属于该类 → 用静态方法。
- 需要访问实例属性 → 用普通实例方法（`self` 参数）。



##### 四、函数与类的区别与适用场景

| 维度     | 函数（Function）                             | 类（Class）                                  |
| -------- | -------------------------------------------- | -------------------------------------------- |
| 核心定位 | 封装**单一功能**的代码块                     | 封装**数据和相关功能**的模板                 |
| 状态管理 | 无状态（每次调用独立，不保存数据）           | 有状态（通过实例属性保存数据）               |
| 代码组织 | 适合线性流程、工具逻辑                       | 适合复杂实体、多属性多行为的场景             |
| 复用方式 | 通过函数调用复用                             | 通过继承、实例化复用                         |
| 典型场景 | 数据计算（如求和）、格式转换（如字符串处理） | 实体建模（如用户、订单）、框架设计（如组件） |

##### 五、相关扩展概念

- **模块（Module）**：以 `.py` 为扩展名的文件，用于组织函数、类和变量（通过 `import` 导入复用）。
- **包（Package**：包含多个模块的目录（需有 `__init__.py`），用于大型项目的代码分层（如 `src/`、`utils/`）。
- **装饰器（Decorator）**：动态给函数或类添加功能（如日志、缓存），本质是高阶函数（或类）。

##### 总结

- **函数**是 “功能的封装”，专注于 “做什么”，适合实现独立、无状态的操作
- **类 ** 是 “实体的模板”，专注于 “是什么” 和 “能做什么”，适合描述复杂对象及其行为，支持封装、继承、多态。

在实际开发中，函数和类并非对立关系：类中可以包含函数（方法），函数也可以操作类的对象。合理结合两者，才能写出简洁、可维护的代码。例如：用类建模 “用户”，用函数实现 “用户数据的批量导入”（工具逻辑）。



 ## 8.2 Python初阶：函数和模块

   ### Python函数（def）以及函数的分类

在 Python 中，函数（用 `def` 关键字定义）是封装可重用代码的基本单元，它将一系列操作打包成一个独立模块，通过函数名调用。函数不仅能简化代码、提高复用性，还能让程序结构更清晰。

#### 一、函数的基本定义与调用

使用 `def` 关键字定义函数的基本语法：

```python
def 函数名(参数列表):
    """函数文档字符串（可选，用于描述功能）"""
    # 函数体（缩进代码块）
    执行语句
    return 返回值  # 可选，无return则默认返回None
```

**示例**：定义一个计算两数之和的函数

```python
def add(a, b):
    """返回两个数的和"""
    return a + b

# 调用函数
result = add(3, 5)
print(result)  # 输出：8
```

#### 二、函数的分类

根据函数的定义者、参数形式和功能，可分为以下几类：

1. **按定义者分类**

（1）内置函数（Built-in Functions）

Python 解释器自带的函数，无需定义可直接使用，如 `print()`、`len()`、`max()` 等。
**示例**：

```python
print(len([1, 2, 3]))  # 内置函数 len() 计算列表长度，输出：3
```

**（2）自定义函数（User-defined Functions）**

由开发者使用 `def` 关键字定义的函数，用于实现特定业务逻辑。
**示例**：

```python
def calculate_area(radius):
    """计算圆的面积"""
    return 3.14 * radius **2
```

**（3）第三方库函数**

来自第三方库（如 `numpy`、`pandas`）提供的函数，需先安装并导入库才能使用。
**示例**：

```python
import numpy as np
print(np.mean([1, 2, 3, 4]))  # 第三方库 numpy 的均值函数，输出：2.5
```

2. 按参数形式分类

**（1）无参函数**

函数定义时没有参数，调用时也无需传递参数，适用于固定逻辑的操作。
**示例**：

```python
def say_hello():
    print("Hello, World!")

say_hello()  # 调用时无需传参，输出：Hello, World!
```

（2）有参函数

函数定义时包含参数，调用时需按要求传递参数，灵活性更高。
**示例**：

```python
def greet(name):  # 单个参数
    print(f"Hello, {name}!")

greet("Alice")  # 传递参数，输出：Hello, Alice!
```

（3）默认参数函数

参数在定义时指定默认值，调用时可省略该参数（使用默认值）。
**示例**：

```python
def power(base, exp=2):  # exp 的默认值为 2
    return base** exp

print(power(3))    # 省略 exp，使用默认值 2 → 3²=9
print(power(3, 3)) # 传递 exp=3 → 3³=27
```

（4）可变参数函数

通过 `*args`（接收任意数量的位置参数）和 `**kwargs`（接收任意数量的关键字参数）实现，适用于参数数量不确定的场景。
**示例**：

```python
def sum_all(*args, **kwargs):
    """计算所有位置参数的和，忽略关键字参数"""
    return sum(args)

print(sum_all(1, 2, 3))  # 位置参数：1+2+3=6
print(sum_all(10, 20, x=30, y=40))  # 关键字参数 x、y 被忽略，结果：30
```

**3. 按返回值分类**

（1）无返回值函数

函数体内没有 `return` 语句，或 `return` 后无值，默认返回 `None`，通常用于执行打印、修改全局变量等操作。
**示例**：

```python
def log(message):
    print(f"[LOG] {message}")  # 仅打印，无返回值

result = log("操作完成")
print(result)  # 输出：None
```

（2）有返回值函数

函数通过 `return` 语句返回一个或多个值（多个值以元组形式返回）。
**示例**：

```python
def divide(a, b):
    quotient = a // b
    remainder = a % b
    return quotient, remainder  # 返回多个值（元组）

q, r = divide(10, 3)  # 解包返回值
print(f"商：{q}，余数：{r}")  # 输出：商：3，余数：1
```

4. **特殊类型函数**

（1）匿名函数（lambda 函数）

用 `lambda` 关键字定义的单行函数，无函数名，适用于简单逻辑。
**示例**：

```python
add = lambda x, y: x + y  # 等价于 def add(x,y): return x+y
print(add(2, 3))  # 输出：5
```

（2）递归函数

在函数体内调用自身的函数，适用于分治问题（如阶乘、斐波那契数列）。
**示例**：

```python
def factorial(n):
    if n == 1:  # 基线条件（终止递归）
        return 1
    return n * factorial(n-1)  # 递归调用自身

print(factorial(5))  # 输出：120（5×4×3×2×1）
```

（3）高阶函数

接受函数作为参数，或返回函数的函数，是函数式编程的核心。
**示例**：

```python
def apply_func(func, x, y):
    """接受函数作为参数并调用"""
    return func(x, y)

# 传递 lambda 函数作为参数
result = apply_func(lambda a, b: a * b, 3, 4)
print(result)  # 输出：12
```

（4）生成器函数

使用 `yield` 关键字返回迭代器的函数，可惰性生成数据（节省内存）。
**示例**：

```python
def generate_numbers(n):
    for i in range(n):
        yield i  # 每次调用返回一个值，暂停执行

# 迭代生成器
for num in generate_numbers(3):
    print(num)  # 输出：0、1、2
```

#### 三、函数的核心特性

1.** 封装性 **：将逻辑隐藏在函数内部，外部只需关注输入输出，无需了解实现细节。
2.** 复用性 **：定义一次可在多处调用，减少重复代码。
3.** 作用域 **：函数内定义的变量为局部变量，仅在函数内有效；函数外的变量为全局变量（需用 `global` 声明才能在函数内修改）。

```python
global_var = 10  # 全局变量

def modify_var():
    local_var = 20  # 局部变量
    global global_var  # 声明使用全局变量
    global_var = 100

modify_var()
print(global_var)  # 输出：100（已被修改）
# print(local_var)  # 报错：局部变量在函数外不可访问
```

#### 总结

函数是 Python 编程的基础组件，通过 `def` 定义的自定义函数可根据参数形式、返回值和功能分为多种类型。合理使用不同类型的函数能显著提升代码的可读性、复用性和可维护性。在实际开发中，应根据场景选择合适的函数类型（如用生成器处理大数据，用递归解决分治问题），并遵循 “单一职责” 原则（一个函数只做一件事）。



   ### Python函数参数分类（必选参数&关键字参数&默认参数&不定长参数）

Python 函数的参数体系灵活且强大，根据传递方式和特性可分为四大类：**必选参数、默认参数、关键字参数和不定长参数**。掌握这些参数类型的用法，能让函数定义更灵活，调用更清晰。

#### 一、必选参数（Positional Arguments）

**定义**：必须按顺序传递的参数，函数调用时必须提供对应的值，否则会报错。
**特点**：

- 定义在参数列表最前面
- 调用时数量和顺序必须与定义一致

**示例**：

```python
def add(a, b):  # a 和 b 都是必选参数
    return a + b

add(2, 3)  # 正确：传递 2 个参数
add(2)     # 错误：缺少必选参数 b（TypeError: add() missing 1 required positional argument: 'b'）
```

#### 二、默认参数（Default Arguments）

**定义**：在函数定义时指定默认值的参数，调用时可省略（使用默认值）。
**特点**：

- 定义时用 `参数名=默认值` 形式
- 必须放在必选参数后面（否则语法错误）
- 调用时若提供值，则覆盖默认值；若省略，则使用默认值

**示例**：

```python
def greet(name, message="Hello"):  # message 是默认参数
    return f"{message}, {name}!"

greet("Alice")          # 省略默认参数，使用默认值 → "Hello, Alice!"
greet("Bob", "Hi")      # 提供值，覆盖默认值 → "Hi, Bob!"
greet(message="Hi", name="Charlie")  # 结合关键字参数，顺序可调整 → "Hi, Charlie!"
```

**注意**：默认参数的默认值**只在函数定义时计算一次，若默认值是可变对象（如列表、字典），可能导致意外行为：

```python
def add_item(item, lst=[]):  # 危险：默认值是可变列表
    lst.append(item)
    return lst

print(add_item(1))  # [1]
print(add_item(2))  # [1, 2]（而非预期的 [2]，因为默认列表被复用）
```

**推荐**：默认值为可变对象时，用 `None` 初始化，在函数内创建新对象：

```python
def add_item(item, lst=None):
    if lst is None:
        lst = []  # 每次调用创建新列表
    lst.append(item)
    return lst
```

#### 三、关键字参数（Keyword Arguments）

**定义**：调用函数时通过 `参数名=值` 形式传递的参数，与定义顺序无关。
**特点**：

- 本质是传递方式的分类（而非定义方式），可用于任何参数类型
- 必须放在位置参数后面（调用时）
- 增强代码可读性，明确参数含义

**示例**：

```python
def describe_person(name, age, city):
    return f"{name} is {age} years old, from {city}."

# 纯位置参数（顺序必须严格对应）
describe_person("Alice", 30, "Beijing")

# 混合位置参数和关键字参数（关键字参数必须在后）
describe_person("Bob", city="Shanghai", age=25)  # 顺序无关

# 纯关键字参数
describe_person(name="Charlie", age=35, city="Guangzhou")
```

#### 四、不定长参数（Variable-Length Arguments）

用于处理**参数数量不确定**的场景，分为两种：接收任意数量的位置参数（`*args`）和关键字参数（`**kwargs`）。

**1. `*args`：接收不定长位置参数**

**定义**：在参数名前加 `*`，用于收集所有未匹配的位置参数，打包成元组（tuple）。
**特点**：

- 名称 `args` 是约定俗成，可改为其他名称（如 `*params`），但推荐用 `args`
- 必须放在必选参数和默认参数后面

**示例**：

```python
def sum_all(*args):  # 收集所有位置参数到元组 args
    return sum(args)

sum_all(1, 2, 3)        # args = (1,2,3) → 6
sum_all(10, 20, 30, 40) # args = (10,20,30,40) → 100
```

**2. `**kwargs`：接收不定长关键字参数**

**定义**：在参数名前加 `**`，用于收集所有未匹配的关键字参数，打包成字典（dict）。
**特点**：

- 名称 `kwargs` 是约定俗成，可改为其他名称（如 `**opts`），但推荐用 `kwargs`
- 必须放在参数列表的最后（所有参数之后）

**示例**：

```python
def print_info(**kwargs):  # 收集所有关键字参数到字典 kwargs
    for key, value in kwargs.items():
        print(f"{key}: {value}")

print_info(name="Alice", age=30, city="Beijing")
# 输出：
# name: Alice
# age: 30
# city: Beijing
```

**3. 组合使用：`*args` 与 `**kwargs`**

可同时使用 `*args` 和 `**kwargs`，顺序必须是：`必选参数 → 默认参数 → *args → **kwargs`。
**示例**：

```python
def func(a, b=0, *args, **kwargs):
    print(f"必选参数 a: {a}")
    print(f"默认参数 b: {b}")
    print(f"不定长位置参数 args: {args}")
    print(f"不定长关键字参数 kwargs: {kwargs}")

func(1, 2, 3, 4, x=5, y=6)
# 输出：
# 必选参数 a: 1
# 默认参数 b: 2
# 不定长位置参数 args: (3, 4)
# 不定长关键字参数 kwargs: {'x': 5, 'y': 6}
```

#### 五、参数定义的顺序规则

函数定义时，参数必须按以下顺序排列，否则会报语法错误：
`必选参数 → 默认参数 → *args → **kwargs`

**正确示例**：

```python
def correct_order(a, b=0, *args, **kwargs):
    pass  # 顺序正确
```

**错误示例**：

```python
def wrong_order(a, *args, b=0, **kwargs):
    pass  # 错误：默认参数 b 放在了 *args 后面
```

#### 六、参数解包（Unpacking）

调用函数时，可通过 `*` 和 `**` 解包可迭代对象，传递给不定长参数：

- `*` 用于解包元组、列表等可迭代对象（作为位置参数）
- `**` 用于解包字典（作为关键字参数）

**示例**：

```python
def sum_numbers(a, b, c):
    return a + b + c

# 解包列表作为位置参数
nums = [1, 2, 3]
print(sum_numbers(*nums))  # 等价于 sum_numbers(1, 2, 3) → 6

# 解包字典作为关键字参数
params = {"a": 10, "b": 20, "c": 30}
print(sum_numbers(**params))  # 等价于 sum_numbers(a=10, b=20, c=30) → 60
```



#### 总结

| 参数类型         | 定义方式           | 调用方式            | 作用                       |
| ---------------- | ------------------ | ------------------- | -------------------------- |
| 必选参数         | `def f(a, b):`     | `f(1, 2)`           | 强制传递，保证基本输入     |
| 默认参数         | `def f(a, b=0):`   | `f(1)` 或 `f(1, 3)` | 提供默认值，简化常见调用   |
| 关键字参数       | （无特殊定义）     | `f(a=1, b=2)`       | 明确参数含义，允许调整顺序 |
| 不定长位置参数   | `def f(*args):`    | `f(1, 2, 3)`        | 接收任意数量的位置参数     |
| 不定长关键字参数 | `def f(**kwargs):` | `f(a=1, b=2)`       | 接收任意数量的关键字参数   |

灵活运用这些参数类型，能让函数既满足固定逻辑需求，又能适应多变的调用场景，写出更简洁、通用的代码。



   ### Python函数的嵌套、函数递归、匿名函数

Python 中函数的嵌套、递归和匿名函数是函数式编程的重要特性，它们分别解决了代码封装、复杂问题分解和简单逻辑简化的需求。以下是详细解析：

#### 一、函数的嵌套（Nested Functions）

**函数的嵌套**指在一个函数（外部函数）内部定义另一个函数（内部函数）。内部函数只能在外部函数的作用域内被调用，外部无法直接访问，从而实现逻辑封装和作用域隔离。

##### 1**. 基本语法**

```python
def outer_function(outer_param):
    # 外部函数的变量/逻辑
    outer_var = "外部变量"
    
    # 内部函数定义（嵌套在外部函数内）
    def inner_function(inner_param):
        # 内部函数可访问外部函数的变量和参数
        return f"内部函数：{inner_param}，外部参数：{outer_param}，外部变量：{outer_var}"
    
    # 外部函数可以调用内部函数，或返回内部函数
    return inner_function  # 返回内部函数对象
```

##### **2. 核心特性**

- **作用域隔离**：内部函数只能在外部函数内部被调用，外部无法直接访问（保护内部逻辑）。

  ```python
  # 错误示例：外部直接调用内部函数
  inner_function(1)  # NameError: name 'inner_function' is not defined
  ```

- **访问外部变量**：内部函数可以访问外部函数的参数和局部变量（但默认不能修改，需用 `nonlocal` 声明）。

  

  ```python
  def outer():
      x = 10
      def inner():
          nonlocal x  # 声明修改外部函数的变量
          x += 5
          print(x)
      inner()  # 调用内部函数
      print(x)  # 外部变量已被修改
  
  outer()  # 输出：15  15
  ```

- **返回内部函数**：外部函数可以返回内部函数，使内部函数在外部被调用（形成 “闭包”）。

  ```python
  # 调用外部函数，获取内部函数对象
  inner = outer_function("外部参数值")
  # 调用返回的内部函数
  print(inner("内部参数值"))  
  # 输出：内部函数：内部参数值，外部参数：外部参数值，外部变量：外部变量
  ```



示例：

```python
def outer_function(outer_param):
    # 外部函数的变量/逻辑
    outer_var = "外部变量"
    
    # 内部函数定义（嵌套在外部函数内）
    def inner_function(inner_param):
        # 内部函数可访问外部函数的变量和参数
        return f"内部函数：{inner_param}，外部参数：{outer_param}，外部变量：{outer_var}"
    
    # 外部函数可以调用内部函数，或返回内部函数
    return inner_function  # 返回内部函数对象

def outer():
    x = 10
    def inner():
        nonlocal x  # 声明修改外部函数的变量
        x += 5
        print(x)
    inner()  # 调用内部函数
    print(x)  # 外部变量已被修改

outer()  # 输出：15  15

# 调用外部函数，获取内部函数对象
inner = outer_function("外部参数值")
# 调用返回的内部函数
print(inner("内部参数值"))  
# 输出：内部函数：内部参数值，外部参数：外部参数值，外部变量：外部变量

inner = outer_function("123")

print(inner(321))
```

输出结果：

```bash
15
15
内部函数：内部参数值，外部参数：外部参数值，外部变量：外部变量
内部函数：321，外部参数：123，外部变量：外部变量
```



##### 3. 典型应用：闭包（Closure）

当外部函数返回内部函数，且内部函数引用了外部函数的变量时，就形成了闭包。闭包可以 “记住” 外部函数的变量状态，常用于装饰器、工厂函数等场景。

**示例：计数器工厂（通过闭包保存计数状态**

```python
def make_counter(initial=0):
    count = initial  # 外部函数的变量，被内部函数引用
    
    def counter():
        nonlocal count
        count += 1
        return count
    
    return counter  # 返回闭包

# 创建两个独立的计数器（状态隔离）
counter1 = make_counter()
counter2 = make_counter(10)

print(counter1())  # 1（counter1 的 count 变为1）
print(counter1())  # 2（counter1 的 count 变为2）
print(counter2())  # 11（counter2 的 count 变为11）
```

#### 二、函数递归（Recursion）

**函数递归**指函数直接或间接调用自身的行为，通过将复杂问题分解为与原问题相似的子问题，简化代码逻辑（如分治算法、树结构遍历等）。

##### 1. 核心要素

递归必须满足两个条件，否则会导致无限递归（栈溢出）：

- **基线条件（Base Case）**：递归终止的条件（当问题足够简单时，直接返回结果，不再递归）。
- **递归条件（Recursive Case）**：将问题分解为更小的子问题，调用自身解决。

##### 2. 基本示例：计算阶乘

阶乘定义：`n! = n × (n-1) × ... × 1`，且 `0! = 1`（基线条件）。

```python
def factorial(n):
    # 基线条件：n=0 时返回1，终止递归
    if n == 0:
        return 1
    # 递归条件：n! = n × (n-1)!
    return n * factorial(n - 1)

print(factorial(5))  # 输出：120（5×4×3×2×1×1）
```

**执行过程**：

```plaintext
factorial(5) → 5 × factorial(4)
factorial(4) → 4 × factorial(3)
factorial(3) → 3 × factorial(2)
factorial(2) → 2 × factorial(1)
factorial(1) → 1 × factorial(0)
factorial(0) → 1（基线条件）
# 反向计算：1×1 → 2×1 → 3×2 → 4×6 → 5×24 → 120
```

##### 3. 常见应用场景

- 数学问题：斐波那契数列、阶乘、幂运算等。
- 数据结构：树的遍历（前序 / 中序 / 后序）、图的深度优先搜索（DFS）。
- 算法：分治算法（快速排序、归并排序）、汉诺塔问题等。

**示例：斐波那契数列（第 n 项）**

```python
def fibonacci(n):
    if n <= 1:  # 基线条件：n=0返回0，n=1返回1
        return n
    # 递归条件：第n项 = 第n-1项 + 第n-2项
    return fibonacci(n-1) + fibonacci(n-2)

print(fibonacci(5))  # 输出：5（数列：0,1,1,2,3,5... 第5项为5）
```

##### 4. 优缺点与注意事项

- **优点**：代码简洁，符合人类思维（直接翻译数学定义或递归逻辑）。
- 缺点：
  - 效率低：重复计算（如斐波那契数列的递归会重复计算大量子问题）。
  - 栈溢出风险：Python 递归深度有限（默认约 1000 层），过深会报错（`RecursionError`）。
- 优化方案：
  - 用缓存（如 `functools.lru_cache`）避免重复计算。
  - 改为迭代实现（效率更高，无栈溢出风险）。
  - 尾递归优化（Python 不支持，但理论上可将递归转为迭代）。

#### 三、匿名函数（Lambda Functions）

**匿名函数**是用 `lambda` 关键字定义的 “一次性” 短函数，没有函数名，仅包含一个表达式，适用于简单逻辑的临时需求。

##### 1. 基本语法

```python
lambda 参数列表: 表达式  # 自动返回表达式的结果
```

- `参数列表`：与普通函数的参数规则一致（可包含必选参数、默认参数、`*args` 等）。
- `表达式`：只能有一个表达式（不能包含循环、条件语句等复杂结构，除非用三元表达式）。

##### 2. 与普通函数的对比

| 特性       | 匿名函数（lambda）           | 普通函数（def）               |
| ---------- | ---------------------------- | ----------------------------- |
| 名称       | 无名称（匿名）               | 有名称                        |
| 定义关键字 | `lambda`                     | `def`                         |
| 函数体     | 仅一个表达式（自动返回结果） | 可包含多个语句（需 `return`） |
| 适用场景   | 简单逻辑（一行可完成）       | 复杂逻辑（多行代码）          |
| 可复用性   | 通常临时使用，不适合复用     | 可多次调用，适合复用          |

**示例：等价的 lambda 与 def 函数**

```python
# 普通函数
def add(a, b):
    return a + b

# 匿名函数（赋值给变量后可调用，等价于上面的 add）
add_lambda = lambda a, b: a + b

print(add(2, 3))        # 5
print(add_lambda(2, 3)) # 5
```

##### 3. 典型应用场景

匿名函数的核心价值是**作为 “临时函数” 传递给高阶函数**（如 `sorted()`、`map()`、`filter()` 等），简化代码。

- **示例 1：作为 `sorted()` 的排序键（key）**

  ```python
  students = [("Alice", 20), ("Bob", 18), ("Charlie", 22)]
  
  # 按年龄排序（用 lambda 定义排序规则）
  sorted_by_age = sorted(students, key=lambda x: x[1])
  print(sorted_by_age)  # [('Bob', 18), ('Alice', 20), ('Charlie', 22)]
  ```

- **示例 2：与 `map()` 配合实现批量转换**

  ```python
  numbers = [1, 2, 3, 4]
  # 用 lambda 定义“平方”逻辑，批量应用到列表
  squared = map(lambda x: x** 2, numbers)
  print(list(squared))  # [1, 4, 9, 16]
  ```

- **示例 3：三元表达式实现简单条件判断**

  ```python
  # lambda 中用三元表达式实现二选一逻辑
  is_positive = lambda x: "正数" if x > 0 else "非正数"
  print(is_positive(5))  # 正数
  print(is_positive(-3)) # 非正数
  ```

##### 4. 局限性

- 只能包含一个表达式，无法实现复杂逻辑（如循环、异常处理）。
- 可读性有限：复杂的 lambda 表达式（如嵌套三元表达式）会降低代码可读性，此时应改用普通函数。
- 不能包含文档字符串（`docstring`），不利于维护和说明功能。

##### 总结

- **函数嵌套**：通过内部函数实现逻辑封装和作用域隔离，核心应用是闭包（保存外部变量状态）。
- **函数递归**：通过调用自身分解问题，需严格定义基线条件，适合数学问题和分治算法，但要注意效率和栈溢出风险。
- **匿名函数（lambda）**：简化简单逻辑的定义，适合作为高阶函数的临时参数，复杂逻辑仍需用普通函数。

这三种特性分别从代码组织、问题分解和简洁性三个维度扩展了 Python 函数的能力，合理使用能显著提升代码质量。



   #### Python函数装饰器（用例讲解）

函数装饰器（Decorator）是 Python 中一种强大的语法，它允许你在不修改原函数代码的前提下，为函数添加额外功能（如日志记录、性能测试、权限验证等）。装饰器本质上是一个**高阶函数**（接收函数作为参数，并返回新函数）。

##### 一、装饰器的基本原理

装饰器的核心逻辑是：

1. 定义一个 “装饰器函数”，接收被装饰的函数作为参数。
2. 在装饰器内部定义一个 “包装函数”（`wrapper`），用于添加额外功能。
3. 包装函数中调用原函数，并返回其结果。
4. 装饰器返回包装函数，替代原函数。

通过 `@装饰器名` 语法，可以简化装饰器的使用（语法糖）。

##### 二、装饰器用例详解

用例 1：基础装饰器（日志记录）

为函数添加调用日志，记录函数名、参数和返回值。

```python
def log_decorator(func):
    # 定义包装函数，接收任意参数
    def wrapper(*args, **kwargs):
        # 调用前：记录函数名和参数
        print(f"调用函数：{func.__name__}，参数：{args}，{kwargs}")
        # 调用原函数
        result = func(*args, **kwargs)
        # 调用后：记录返回值
        print(f"函数 {func.__name__} 返回：{result}")
        return result  # 返回原函数结果
    return wrapper  # 返回包装函数

# 使用装饰器（等价于 add = log_decorator(add)）
@log_decorator
def add(a, b):
    return a + b

# 测试
add(2, 3)
# 输出：
# 调用函数：add，参数：(2, 3)，{}
# 函数 add 返回：5

```

**执行流程**：

- `@log_decorator` 等价于 `add = log_decorator(add)`，即 `add` 被替换为 `wrapper` 函数。
- 调用 `add(2, 3)` 时，实际执行的是 `wrapper(2, 3)`，先打印日志，再调用原 `add` 函数。

**用例 2：带参数的装饰器（条件日志）**

装饰器本身可以接收参数，实现更灵活的功能（如控制日志级别）。

```python
# 外层函数：接收装饰器参数
def log_level(level):
    # 中层函数：接收被装饰函数
    def decorator(func):
        # 内层包装函数：根据参数添加功能
        def wrapper(*args, **kwargs):
            print(f"[{level}] 调用函数：{func.__name__}")
            result = func(*args, **kwargs)
            print(f"[{level}] 函数 {func.__name__} 执行完成")
            print(result)
            return result
        return wrapper
    return decorator

# 使用带参数的装饰器（指定日志级别）
@log_level("INFO")
def multiply(a, b):
    return a * b

@log_level("DEBUG")
def divide(a, b):
    return a / b

# 测试
multiply(3, 4)
# 输出：
# [INFO] 调用函数：multiply
# [INFO] 函数 multiply 执行完成

divide(10, 2)
# 输出：
# [DEBUG] 调用函数：divide
# [DEBUG] 函数 divide 执行完成

```

**原理**：

- `@log_level("INFO")` 先执行 `log_level("INFO")`，返回 `decorator` 函数。
- 再执行 `multiply = decorator(multiply)`，完成装饰。

用例 3：装饰器保留原函数信息（`functools.wraps`）

默认情况下，装饰后的函数会丢失原函数的元信息（如函数名、文档字符串），需用 `functools.wraps` 修复。

```python
import functools

def my_decorator(func):
    # 用 wraps 装饰 wrapper，继承原函数的元信息
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        """包装函数的文档字符串"""
        return func(*args, **kwargs)
    return wrapper

@my_decorator
def original_func():
    """原函数的文档字符串"""
    pass

# 对比：未用 wraps 时，以下会输出 wrapper 的信息
print(original_func.__name__)  # 输出：original_func（而非 wrapper）
print(original_func.__doc__)   # 输出：原函数的文档字符串（而非包装函数的）

```

**为什么需要？**
调试时（如打印函数名）或生成文档时，保留原函数信息能避免混淆。

**用例 4：装饰器嵌套（多功能组合）**

一个函数可以被多个装饰器装饰，执行顺序为**从下到上**（靠近函数的装饰器先执行）。

```python
import functools

# 装饰器1：计时
def timer(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        import time
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(f"函数 {func.__name__} 耗时：{end - start:.4f}秒")
        return result
    return wrapper

# 装饰器2：日志
def logger(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        print(f"执行函数：{func.__name__}")
        result = func(*args, **kwargs)
        print(f"函数 {func.__name__} 执行结束")
        return result
    return wrapper

# 嵌套装饰：先执行 logger，再执行 timer（顺序从下到上）
@timer
@logger
def slow_function(seconds):
    import time
    time.sleep(seconds)  # 模拟耗时操作
    return "完成"

# 测试
slow_function(1)
# 输出：
# 执行函数：slow_function （logger 的前置操作）
# 函数 slow_function 执行结束 （logger 的后置操作）
# 函数 slow_function 耗时：1.0012秒 （timer 的后置操作）

```

**执行顺序**：
`@timer` 装饰 `@logger` 装饰后的函数，因此实际执行流程是：
`timer.wrapper` → `logger.wrapper` → 原函数 `slow_function`。

**用例 5：类装饰器（面向对象风格）**

除了函数，类也可以作为装饰器（需实现 `__call__` 方法，使类实例可调用）。

```python
class CountCalls:
    def __init__(self, func):
        # 初始化：接收被装饰函数
        self.func = func
        self.count = 0  # 记录调用次数

    def __call__(self, *args, **kwargs):
        # 使类实例可调用（模拟函数行为）
        self.count += 1
        print(f"函数 {self.func.__name__} 已调用 {self.count} 次")
        return self.func(*args, **kwargs)

@CountCalls  # 等价于：add = CountCalls(add)
def add(a, b):
    return a + b

# 测试
add(1, 2)  # 输出：函数 add 已调用 1 次
add(3, 4)  # 输出：函数 add 已调用 2 次

```

**优势**：类装饰器可通过实例变量（如 `self.count`）更方便地保存状态（相比函数装饰器的闭包更直观）。



##### 三、装饰器的常见应用场景

1. **日志记录**：自动记录函数调用、参数、返回值。
2. **性能测试**：统计函数执行时间。
3. **权限验证**：调用函数前检查用户权限（如 Web 框架中的登录验证）。
4. **缓存结果**：缓存函数调用结果，避免重复计算（如 `functools.lru_cache`）。
5. **输入验证**：检查函数参数是否符合要求。

##### 总结

装饰器是 Python 中 “开闭原则”（对扩展开放，对修改关闭）的典型实现，其核心价值在于：

- 不修改原函数代码，即可添加功能。
- 代码复用性高，同一装饰器可应用于多个函数。
- 逻辑清晰，将 “业务逻辑” 与 “辅助功能” 分离。

掌握装饰器能让你写出更简洁、灵活、可维护的代码，尤其在框架开发和工具库设计中应用广泛。





   ### Python模块和包的分类

在 Python 中，**模块（Module）** 和**包（Package）** 是代码组织的核心单元，用于将函数、类、变量等按功能拆分，实现代码复用和结构化管理。它们的分类可以从**来源**、**功能**、**结构**等多个维度划分，以下是详细分类：

### 一、模块（Module）的分类

模块是一个以 `.py` 为扩展名的文件，包含 Python 代码（函数、类、变量等）。其分类主要基于**来源**、**功能**和**加载方式**：

#### 1. 按来源分类（最常用）

根据模块的开发主体，可分为三类：

##### （1）内置模块（Built-in Modules）

- **定义**：Python 解释器自带的模块，无需安装，直接通过 `import` 导入即可使用。

- **特点**：由 C 语言或 Python 编写，性能高效，覆盖基础功能。

- **示例**：

  - 系统交互：`sys`（解释器信息）、`os`（操作系统接口）。
  - 数据处理：`json`（JSON 编解码）、`datetime`（日期时间处理）。
  - 基础工具：`math`（数学运算）、`random`（随机数生成）。

  

  ```python
  import sys
  print(sys.version)  # 打印 Python 版本（内置模块用法）
  ```

##### （2）第三方模块（Third-party Modules）

- **定义**：由社区或第三方开发者开发的模块，需通过包管理工具（如 `pip`）安装后使用。

- **特点**：覆盖各类细分领域（如 Web 开发、数据分析、人工智能等），是 Python 生态丰富性的核心。

- **示例**：

  - 网络请求：`requests`（HTTP 客户端）。
  - 数据分析：`pandas`（数据处理）、`numpy`（数值计算）。
  - Web 框架：`flask`（轻量 Web 框架）、`django`（全栈 Web 框架）。

  

  ```bash
  # 安装第三方模块
  pip install requests
  ```

  

  ```python
  import requests
  response = requests.get("https://www.baidu.com")  # 第三方模块用法
  ```

##### （3）自定义模块（User-defined Modules）

- **定义**：由开发者根据自身需求编写的 `.py` 文件，用于封装项目中复用的逻辑。

- **特点**：按需设计，与项目业务强相关，是项目代码组织的基础。

- 示例

  ：

  若创建

  ```
  my_utils.py
  ```

  文件：

  ```python
  # my_utils.py（自定义模块）
  def add(a, b):
      return a + b
  ```

  可在其他文件中导入使用：

  ```python
  import my_utils
  print(my_utils.add(2, 3))  # 输出：5（自定义模块用法）
  ```

#### 2. 按功能分类

根据模块实现的功能，可分为：

- **系统基础模块**：处理与操作系统交互的功能，如 `os`（文件操作）、`sys`（解释器配置）、`pathlib`（路径处理）。
- **数据处理模块**：处理数据编解码、转换等，如 `json`、`csv`（CSV 文件）、`pickle`（Python 对象序列化）。
- **网络模块**：处理网络通信，如 `socket`（底层网络接口）、`http`（HTTP 协议）、`urllib`（URL 处理）。
- **数学与科学计算模块**：如 `math`（基础数学）、`statistics`（统计函数）、`numpy`（第三方，数值计算）。
- **Web 与 IO 模块**：如 `flask`（第三方 Web 框架）、`logging`（日志处理）、`argparse`（命令行参数解析）。

#### 3. 按加载方式分类

根据模块的编译和加载形式，可分为：

- **源码模块（Source Modules）**：以 `.py` 为扩展名的纯 Python 代码文件，加载时由解释器动态编译。
- **字节码模块（Bytecode Modules）**：以 `.pyc` 或 `.pyo` 为扩展名的编译后文件（由 `.py` 编译生成），加载速度更快（避免重复编译）。
- **扩展模块（Extension Modules）**：由 C/C++ 等编译型语言编写的二进制文件（如 `.pyd` 或 `.so`），用于提升性能或调用底层系统接口（如 `_socket` 是 `socket` 模块的 C 实现）。

### 二、包（Package）的分类

包是**包含多个模块的目录**，必须包含 `__init__.py` 文件（Python 3.3+ 允许省略，但仍推荐保留以明确标识为包）。其分类主要基于**来源**、**结构**和**功能**：

#### 1. 按来源分类（与模块对应）

##### （1）内置包（Built-in Packages）

- **定义**：Python 标准库中的包，由多个相关模块组成，无需安装。

- **示例**：

  - `os.path`：`os` 包下的 `path` 子包，处理路径相关功能。
  - `xml`：包含 `xml.etree`、`xml.dom` 等模块，处理 XML 数据。
  - `http`：包含 `http.client`、`http.server` 等模块，处理 HTTP 相关功能。

  ```python
  from os.path import join  # 导入内置包的子模块
  print(join("a", "b"))  # 输出：a/b（路径拼接）
  ```

##### （2）第三方包（Third-party Packages）

- **定义**：由社区开发的包含多个模块的功能集合，需通过 `pip` 安装，通常比单个模块更复杂（可能包含多级子包）。

- **示例**：

  - `pandas`：数据分析包，包含 `pandas.core`、`pandas.io` 等子包。
  - `flask`：Web 框架包，包含 `flask.app`、`flask.routing` 等子包。
  - `scikit-learn`：机器学习包，包含 `sklearn.model_selection`、`sklearn.ensemble` 等子包。

  ```bash
  pip install pandas  # 安装第三方包
  ```

  

  ```python
  from pandas import DataFrame  # 导入第三方包的类
  df = DataFrame({"name": ["Alice"]})  # 使用第三方包
  ```

##### （3）自定义包（User-defined Packages）

- **定义**：开发者为项目创建的包，用于组织多个相关模块（通常按功能拆分）。

- 结构示例

  ：一个处理用户管理的自定义包

  ```
  user
  ```

  ：

  ```plaintext
  user/                  # 包目录
  ├── __init__.py        # 包标识文件（可空，或定义导出内容）
  ├── models.py          # 模块：用户数据模型
  ├── services.py        # 模块：用户业务逻辑
  └── utils.py           # 模块：用户相关工具函数
  ```

  使用方式：

  ```python
  from user.models import User  # 导入自定义包的模块
  user = User(name="Alice")
  ```

#### 2. 按结构分类

根据包的嵌套层级，可分为：

##### （1）单级包（Flat Package）

- **定义**：仅包含一个目录和若干模块，无嵌套子包。
- **示例**：上述 `user` 包（仅 `user/` 一级目录，内部是模块文件）。

##### （2）多级包（Nested Package）

- **定义**：包内部包含子包，形成层级结构（如 `a.b.c`），适合大型项目。

- 示例

  ：一个电商项目的包结构：

  ```plaintext
  ecommerce/                # 一级包
  ├── __init__.py
  ├── user/                 # 子包（二级）
  │   ├── __init__.py
  │   └── models.py
  ├── order/                # 子包（二级）
  │   ├── __init__.py
  │   └── services.py
  └── payment/              # 子包（二级）
      ├── __init__.py
      └── utils.py
  ```

  使用方式：

  ```python
  from ecommerce.order.services import create_order  # 多级包导入
  ```

#### 3. 按功能分类

根据包的业务领域，可分为：

- **框架包**：提供完整开发框架，如 `django`（Web 开发）、`tensorflow`（深度学习）。
- **工具包**：提供通用工具功能，如 `utils`（自定义工具包）、`python-dateutil`（日期工具）。
- **领域包**：针对特定领域，如 `pandas`（数据分析）、`pygame`（游戏开发）、`sqlalchemy`（数据库 ORM）。

### 三、模块与包的核心区别

| 维度     | 模块（Module）             | 包（Package）                                     |
| -------- | -------------------------- | ------------------------------------------------- |
| 形式     | 单个 `.py` 文件            | 包含多个模块的目录（含 `__init__.py`）            |
| 作用     | 封装单一或相关功能的代码块 | 组织多个相关模块，形成功能集合                    |
| 导入方式 | `import 模块名`            | `import 包名.模块名` 或 `from 包名 import 模块名` |

### 总结

- **模块**按来源可分为内置、第三方、自定义模块，是代码复用的基础单元。
- **包**是模块的集合，按来源同样分为内置、第三方、自定义包，按结构可分为单级和多级包，适合大型项目的代码组织。

理解模块和包的分类，有助于高效使用 Python 生态（如选择合适的第三方库）和设计清晰的项目结构（如合理拆分自定义模块和包）。



   ### Python模块的导入（import&from...import...）

Python 中模块的导入是代码复用的核心机制，通过 `import` 和 `from...import...` 语句可以使用其他模块（或包）中的函数、类、变量等。两种方式各有特点，适用于不同场景，以下是详细讲解：

### 一、基本导入方式：`import 模块名`

**语法**：`import 模块名 [as 别名]`
**作用**：导入整个模块，使用时需通过 “模块名。成员” 的形式访问模块内的函数、类或变量。

#### 1. 基础用法

```python
# 导入内置模块 math
import math

# 使用模块中的函数（模块名.函数名）
print(math.sqrt(16))  # 输出：4.0（调用math模块的sqrt函数）
print(math.pi)        # 输出：3.141592653589793（访问math模块的变量pi）
```

#### 2. 别名（`as`）：简化模块名

当模块名较长或存在命名冲突时，可用 `as` 指定别名：

```python
# 导入第三方模块 pandas，并指定别名为 pd（行业惯例）
import pandas as pd

# 使用别名访问
df = pd.DataFrame({"name": ["Alice"]})  # 等价于 pandas.DataFrame
```

#### 3. 一次导入多个模块

可在一行导入多个模块（按惯例用空格分隔，或换行对齐）：

```python
import math, sys, os  # 一行导入多个模块（不推荐，可读性差）

# 推荐：换行对齐，更清晰
import math
import sys
import os
```

**特点**：

- 优点：避免命名冲突（通过模块名隔离），适合需要使用模块中多个成员的场景。
- 缺点：每次使用需带模块名，代码稍长。

### 二、部分导入：`from...import...`

**语法**：`from 模块名 import 成员名 [as 别名]`
**作用**：仅导入模块中指定的成员（函数、类、变量），使用时可直接通过成员名访问，无需带模块名。

#### 1. 导入单个成员

```python
# 从 math 模块中仅导入 sqrt 函数
from math import sqrt

# 直接使用成员名，无需带模块名
print(sqrt(25))  # 输出：5.0
```

#### 2. 导入多个成员

```python
# 从 math 模块中导入 sqrt 和 pi 两个成员
from math import sqrt, pi

print(sqrt(9))  # 3.0
print(pi)       # 3.141592653589793
```

#### 3. 别名（`as`）：避免命名冲突

若导入的成员与当前作用域的变量 / 函数重名，可用 `as` 重命名：

```python
# 当前作用域已有名为 sum 的变量
sum = 100

# 从 math 模块导入 sum 函数时指定别名
from math import sum as math_sum

print(math_sum([1, 2, 3]))  # 输出：6（调用math的sum函数）
print(sum)                  # 输出：100（当前作用域的sum变量）
```

#### 4. 导入所有成员（`*`）

用 `*` 可导入模块中所有公开成员（不推荐，易导致命名冲突）：

```python
# 导入 math 模块的所有公开成员
from math import *

print(sqrt(36))  # 6.0
print(cos(0))    # 1.0（math模块的cos函数）
```

**注意**：模块可通过 `__all__` 变量控制 `from...import *` 导入的成员（仅包含在 `__all__` 中的成员会被导入）：
例如，`my_module.py` 中定义：

```python
# my_module.py
__all__ = ["add", "PI"]  # 控制 from...import * 仅导入 add 和 PI

def add(a, b):
    return a + b

def subtract(a, b):
    return a - b

PI = 3.14
```

则导入时：

```python
from my_module import *
add(2, 3)  # 正常使用（在__all__中）
PI         # 正常使用（在__all__中）
subtract(5, 2)  # 报错：未被导入（不在__all__中）
```

**特点**：

- 优点：使用成员时无需带模块名，代码更简洁，适合仅需模块中少数成员的场景。
- 缺点：可能导致命名冲突（不同模块的成员同名时覆盖），`from...import *` 会污染命名空间，不推荐在大型项目中使用。

### 三、从包中导入模块 / 成员

包是包含多个模块的目录，导入包中的模块或成员时，需指定完整路径（包名。模块名）。

#### 1. 导入包中的模块（`import`）

```python
# 假设有包结构：mypackage/utils.py，其中包含函数 format_data
import mypackage.utils

# 使用：包名.模块名.函数名
mypackage.utils.format_data("test")
```

可用 `as` 简化：

```python
import mypackage.utils as utils
utils.format_data("test")  # 简化后
```

#### 2. 从包中导入模块的成员（`from...import...`）

```python
# 从包的模块中导入指定函数
from mypackage.utils import format_data

format_data("test")  # 直接使用
```

也可先导入模块，再从模块中导入成员：

```python
from mypackage import utils  # 先导入模块
from utils import format_data  # 再从模块中导入成员
```

### 四、导入的搜索路径

Python 导入模块时，会按以下顺序搜索路径（可通过 `sys.path` 查看）：

1. 当前执行脚本所在目录
2. 系统环境变量 `PYTHONPATH` 中的路径
3. Python 标准库目录
4. 第三方库安装目录（如 `site-packages`）

若模块不在这些路径中，导入会报错（`ModuleNotFoundError`），需手动将模块所在目录添加到 `sys.path`：

```python
import sys
sys.path.append("/path/to/module/directory")  # 添加路径
import my_module  # 现在可导入
```

### 五、常见问题与最佳实践

1. **避免循环导入**：模块 A 导入模块 B，同时模块 B 导入模块 A，会导致报错。解决方法：重构代码，将共享逻辑抽离到新模块。
2. **慎用 `from...import \*`**：易引发命名冲突，推荐显式导入所需成员。
3. **优先使用相对导入（包内部）**：在包内部模块间导入时，可用相对路径（如 `from . import module`，`.` 表示当前目录）。
4. **遵循命名规范**：模块名用小写字母，多个单词用下划线连接（如 `data_process.py`），避免与标准库模块重名（如不要命名为 `json.py`）。

### 总结

| 导入方式                | 语法示例                | 适用场景                             | 优点         | 缺点                     |
| ----------------------- | ----------------------- | ------------------------------------ | ------------ | ------------------------ |
| `import 模块名`         | `import math`           | 使用模块中多个成员，避免命名冲突     | 隔离命名空间 | 需带模块名，代码较长     |
| `from 模块 import 成员` | `from math import sqrt` | 使用模块中少数成员，追求代码简洁     | 调用方便     | 可能引发命名冲突         |
| `from 模块 import *`    | `from math import *`    | 临时测试或快速使用（不推荐正式代码） | 无需指定成员 | 命名空间污染，冲突风险高 |

根据实际需求选择合适的导入方式，既能保证代码简洁，又能避免潜在的命名冲突问题。



   ### Python标准库（date, datetime, os模块, json模块, jsonpath模块, 文件处理）

Python 标准库包含了大量实用模块，涵盖了日常开发中常见的功能需求。以下重点介绍与日期时间处理、系统交互、JSON 操作及文件处理相关的核心模块，包括 `datetime`、`os`、`json` 等，并补充说明非标准库但常用的 `jsonpath`：

### 一、`datetime` 模块：日期与时间处理

`datetime` 模块提供了处理日期和时间的类，比内置的 `time` 模块更直观，主要包含 `date`（日期）、`time`（时间）、`datetime`（日期时间）、`timedelta`（时间差）等类。

#### 1. 核心类及用法

- **`date`**：处理年、月、日

  ```python
  from datetime import date
  
  # 创建日期对象（年, 月, 日）
  d = date(2023, 10, 1)
  print(d.year)   # 2023
  print(d.month)  # 10
  print(d.day)    # 1
  print(d.weekday())  # 6（周一为0，周日为6）
  
  # 获取当前日期
  today = date.today()
  print(today)  # 2023-10-01（格式：YYYY-MM-DD）
  ```

- **`time`**：处理时、分、秒、微秒

  ```python
  from datetime import time
  
  # 创建时间对象（时, 分, 秒, 微秒）
  t = time(15, 30, 45, 100000)
  print(t.hour)   # 15
  print(t.minute) # 30
  print(t.second) # 45
  ```

- **`datetime`**：同时处理日期和时间（最常用）

  ```python
  from datetime import datetime
  
  # 创建日期时间对象（年, 月, 日, 时, 分, 秒）
  dt = datetime(2023, 10, 1, 15, 30, 45)
  print(dt)  # 2023-10-01 15:30:45
  
  # 获取当前日期时间
  now = datetime.now()
  print(now)  # 2023-10-01 15:30:45.123456（包含微秒）
  ```

- **`timedelta`**：计算时间差（用于日期加减）

  ```python
  from datetime import datetime, timedelta
  
  now = datetime.now()
  # 3天后
  future = now + timedelta(days=3)
  # 2小时前
  past = now - timedelta(hours=2)
  
  print(f"现在：{now}")
  print(f"3天后：{future}")
  print(f"2小时前：{past}")
  ```

#### 2. 格式化与解析（`strftime` 与 `strptime`）

- **`strftime`**：将日期时间对象转为字符串（格式化）

  ```python
  now = datetime.now()
  # 格式化为 "年-月-日 时:分:秒"
  print(now.strftime("%Y-%m-%d %H:%M:%S"))  # 2023-10-01 15:30:45
  ```

  常用格式符：`%Y`（4 位年）、`%m`（2 位月）、`%d`（2 位日）、`%H`（24 小时制时）、`%M`（分）、`%S`（秒）。

- **`strptime`**：将字符串解析为日期时间对象

  ```python
  date_str = "2023-10-01"
  # 解析字符串为date对象
  d = datetime.strptime(date_str, "%Y-%m-%d").date()
  print(d)  # 2023-10-01
  ```

### 二、`os` 模块：与操作系统交互

`os` 模块提供了访问操作系统功能的接口，主要用于文件 / 目录操作、环境变量、进程管理等。

#### 1. 常用功能

- **获取 / 切换当前目录**

  ```python
  import os
  
  # 获取当前工作目录
  cwd = os.getcwd()
  print(cwd)  # 例如：/home/user/project
  
  # 切换工作目录
  os.chdir("/home/user")
  ```

- **目录操作**

  ```python
  # 列出目录下的文件和子目录
  print(os.listdir("."))  # 当前目录内容
  
  # 创建单级目录（目录已存在会报错）
  os.mkdir("test_dir")
  
  # 创建多级目录（递归创建）
  os.makedirs("a/b/c", exist_ok=True)  # exist_ok=True：目录存在时不报错
  
  # 删除空目录（非空目录会报错）
  os.rmdir("test_dir")
  ```

- **文件操作**

  ```python
  # 删除文件
  os.remove("test.txt")  # 文件不存在会报错
  
  # 重命名文件/目录
  os.rename("old.txt", "new.txt")
  ```

- **路径处理（`os.path` 子模块）**

  ```python
  from os.path import join, exists, isfile, isdir
  
  # 拼接路径（自动处理不同系统的路径分隔符）
  path = join("a", "b", "file.txt")  # Windows 会转为 "a\b\file.txt"
  
  # 判断路径是否存在
  print(exists(path))  # True/False
  
  # 判断是否为文件/目录
  print(isfile(path))  # True（如果是文件）
  print(isdir("a"))    # True（如果是目录）
  ```

### 三、`json` 模块：JSON 数据处理

`json` 模块用于实现 Python 数据类型与 JSON 格式的相互转换（序列化与反序列化）。

#### 1. 核心函数

- **序列化（Python → JSON）**：`json.dumps()`（转为字符串）、`json.dump()`（写入文件）

  ```python
  import json
  
  # Python 字典（对应 JSON 对象）
  data = {
      "name": "Alice",
      "age": 30,
      "hobbies": ["reading", "coding"]
  }
  
  # 转为 JSON 字符串
  json_str = json.dumps(data, indent=2)  # indent：格式化输出（美观）
  print(json_str)
  # 输出：
  # {
  #   "name": "Alice",
  #   "age": 30,
  #   "hobbies": [
  #     "reading",
  #     "coding"
  #   ]
  # }
  
  # 直接写入 JSON 文件
  with open("data.json", "w", encoding="utf-8") as f:
      json.dump(data, f, indent=2, ensure_ascii=False)  # ensure_ascii=False：保留中文
  ```

- **反序列化（JSON → Python）**：`json.loads()`（从字符串读取）、`json.load()`（从文件读取）

  ```python
  # 从 JSON 字符串解析
  json_str = '{"name": "Bob", "age": 25}'
  data = json.loads(json_str)
  print(data["name"])  # Bob（Python 字典）
  
  # 从 JSON 文件读取
  with open("data.json", "r", encoding="utf-8") as f:
      data = json.load(f)
  print(data["hobbies"])  # ['reading', 'coding']
  ```

#### 2. 注意事项

- JSON 支持的数据类型有限（字符串、数字、布尔、数组、对象、null），Python 中的 `tuple` 会被转为 JSON 数组，`None` 会转为 JSON `null`。
- 自定义对象序列化需通过 `default` 参数指定转换函数（如 `json.dumps(obj, default=lambda x: x.__dict__)`）。

### 四、`jsonpath` 模块：JSON 数据解析（非标准库）

`jsonpath` 不是 Python 标准库（需通过 `pip install jsonpath` 安装），用于从复杂 JSON 数据中提取指定内容，类似 XPath 之于 XML。

#### 基本用法

假设有 JSON 数据：

```python
data = {
    "store": {
        "book": [
            {"title": "Python Guide", "price": 50},
            {"title": "Java Guide", "price": 60}
        ],
        "bicycle": {"color": "red", "price": 300}
    }
}
```

使用 `jsonpath` 提取数据：

```python
from jsonpath import jsonpath

# 提取所有书的标题（$ 表示根节点，.. 表示递归查找）
titles = jsonpath(data, "$..book[*].title")
print(titles)  # ['Python Guide', 'Java Guide']

# 提取价格大于50的物品
expensive = jsonpath(data, "$..[?(@.price > 50)]")
print(expensive)  # [{'title': 'Java Guide', 'price': 60}, {'color': 'red', 'price': 300}]
```

常用语法：`$`（根）、`.[index]`（数组索引）、`.*`（所有子节点）、`..key`（递归查找 key）、`?()`（过滤条件）。

### 五、文件处理（内置 `open` 函数 + 标准库）

Python 通过内置的 `open` 函数结合 `os`、`shutil` 等模块实现文件读写和管理。

#### 1. 文件读写基础（`open` 函数）

`open(file, mode='r', encoding=None)` 用于打开文件，返回文件对象，常用模式：

- `r`：只读（默认）；`w`：写入（覆盖原有内容）；`a`：追加（在末尾添加）。
- `b`：二进制模式（如 `rb`、`wb`，用于非文本文件如图片）。

**示例：文本文件读写**

```python
# 写入文件
with open("test.txt", "w", encoding="utf-8") as f:  # with 语句自动关闭文件
    f.write("Hello, Python!\n")  # 写入一行
    f.writelines(["First line\n", "Second line\n"])  # 写入多行

# 读取文件
with open("test.txt", "r", encoding="utf-8") as f:
    content = f.read()  # 读取全部内容
    # line = f.readline()  # 读取一行
    # lines = f.readlines()  # 读取所有行（列表）
print(content)
```

#### 2. 高级文件操作（`shutil` 模块）

`shutil` 是标准库，提供更高级的文件操作（复制、移动、删除目录等）：

```python
import shutil

# 复制文件
shutil.copy("source.txt", "dest.txt")  # 复制内容和权限
shutil.copy2("source.txt", "dest.txt")  # 保留元数据（如创建时间）

# 移动文件/目录（类似剪切）
shutil.move("old_dir", "new_dir")

# 删除非空目录（递归删除，谨慎使用！）
shutil.rmtree("dir_to_delete")
```

### 总结

| 模块 / 功能 | 核心作用                    | 关键函数 / 类                                    |
| ----------- | --------------------------- | ------------------------------------------------ |
| `datetime`  | 日期时间处理                | `date`、`datetime`、`timedelta`、`strftime`      |
| `os`        | 操作系统交互（文件 / 目录） | `os.getcwd()`、`os.makedirs()`、`os.path.join()` |
| `json`      | JSON 序列化与反序列化       | `dumps()`、`loads()`、`dump()`、`load()`         |
| `jsonpath`  | 提取 JSON 数据（非标准库）  | `jsonpath()`                                     |
| 文件处理    | 读写文件、高级操作          | `open()`、`shutil.copy()`、`shutil.move()`       |

这些模块是 Python 日常开发的基础工具，掌握它们能高效处理日期、系统交互、数据格式转换和文件管理等常见需求。





   ### Python输入输出（print&input及基础输出优化）







   ### Python异常处理（捕获异常try...except...finally&抛出异常raise）







 ## 8.3 Python高阶：面向对象编程

   ### 面向对象编程（类的创建，init，self，del）







   ### 面向对象编程（类属性、实例属性、内置属性）







   ### 面向对象编程（类方法、实例方法、内置方法、静态方法）







   ### 面向对象三大特性：封装、继承（继承的好处和多继承）、多态







   ### Python常用第三方库的应用







   ### Python面向对象和异常以及应用







   ### Python面向对象异常详解（类的缺陷，自定义缺陷）







 ## 8.4 Python高阶：自动化框架专题

   ### Logging日志处理模块（logging, FileHandler, StreamHandler, 日志等级）







   ### Python序列化和反序列化详解







   ### 外部数据库MySQL高级应用（MySqldb、Python操作实现CURD、事务机制）







   ### 外部数据库Mysql常用管理（yum安装、yum卸载、pyyaml模块操作）







   ### 外部配置文件Excel/Csv的读取（xlrd、xlwt、pandas、openpyxl、二次封装）







   ### Python正则表达式（json、Xpath、email、ip地址等）





