---
layout: post
title:  "Shell 脚本"
date:   2025-10-12 20:18:00 +0800
categories: 软件测试
tags: 软件测试 python  
author: PandHedge
mathjax: true
---
## 核心知识点

### 一、Shell 脚本基础

| 知识点     | 语法 / 说明                       | 示例                              |
| ---------- | --------------------------------- | --------------------------------- |
| 脚本定义   | 以`#!/bin/bash`开头（指定解释器） | `#!/bin/bash`（脚本第一行必须写） |
| 脚本作用   | 批量执行命令、实现自动化任务      | 一键部署服务、日志分析等          |
| 执行方式 1 | 赋予权限后直接执行                | `chmod +x test.sh; ./test.sh`     |
| 执行方式 2 | 通过 bash 解释器执行（无需权限）  | `bash test.sh`                    |

### 二、变量操作

| 操作类型 | 语法 / 说明                                 | 示例                                                  |
| -------- | ------------------------------------------- | ----------------------------------------------------- |
| 定义变量 | 变量名 = 值（等号前后无空格）               | `name="shell"`                                        |
| 引用变量 | $变量名 或 ${变量名}（避免歧义）            | `echo $name` 或 `echo ${name}_test`                   |
| 取消变量 | unset 变量名                                | `unset name`                                          |
| 只读变量 | readonly 变量名 = 值                        | `readonly pi=3.14`（无法修改）                        |
| 位置参数 | $n（n为数字，$0 是脚本名，$1-$9 是参数）    | `echo "第1个参数：$1"`（执行`./test.sh 123`输出 123） |
| 特殊变量 | ：参数个数；*：所有参数；$?：上条命令退出码 | `echo "参数总数：$#"`（执行`./test.sh a b`输出 2）    |

### 三、输入与输出

| 操作类型     | 语法 / 说明                   | 示例                                  |                             |
| ------------ | ----------------------------- | ------------------------------------- | --------------------------- |
| 输出内容     | echo "内容"（可解析变量）     | `echo "Hello, $USER"`（输出当前用户） |                             |
| 读取用户输入 | read 变量名（默认等待输入）   | `read age; echo "年龄：$age"`         |                             |
| 输出重定向   | > 覆盖写入；>> 追加写入       | `echo "log" > app.log`                |                             |
| 输入重定向   | < 从文件读取输入              | `read content < file.txt`             |                             |
| 管道符       | ｜ 将前命令输出作为后命令输入 | `ls -l                                | grep ".sh"`（筛选.sh 文件） |

### 四、条件判断（if 语句）

| 语法结构               | 说明                                                         | 示例（单行简化）                                             |
| ---------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 基本结构               | if [[条件]]; then 命令；fi                                   | `if [[ 1 -eq 1 ]]; then echo "相等"; fi`                     |
| 多条件（if-else）      | if [[条件]]; then 命令；else 命令；fi                        | `if [[ $age -ge 18 ]]; then echo "成年"; else echo "未成年"; fi` |
| 多分支（if-elif-else） | if [[条件 1]]; then 命令 1; elif [[ 条件 2 ]]; then 命令 2; else 命令 3; fi | `if [[ $score -gt 90 ]]; then echo "优秀"; elif [[ $score -gt 60 ]]; then echo "及格"; else echo "不及格"; fi` |
| 常用比较运算符         | -eq（等于）、-ne（不等于）、-gt（大于）、-lt（小于）、-ge（大于等于）、-le（小于等于）（数字比较）；==（等于）、!=（不等于）（字符串比较） | `[[ "a" == "a" ]]`（字符串相等）；`[[ 5 -gt 3 ]]`（数字 5>3） |
| 文件判断运算符         | -f（是否为文件）、-d（是否为目录）、-r（是否可读）           | `if [[ -f "test.sh" ]]; then echo "是文件"; fi`              |

### 五、循环语句

| 循环类型                     | 语法 / 说明                                 | 示例（单行简化）                                             |
| ---------------------------- | ------------------------------------------- | ------------------------------------------------------------ |
| for 循环（遍历列表）         | for 变量 in 列表；do 命令；done             | `for i in 1 2 3; do echo $i; done`（输出 1 2 3）             |
| for 循环（C 风格）           | for ((i=1; i<=5; i++)); do 命令；done       | `for ((i=1; i<=5; i++)); do echo $i; done`（输出 1-5）       |
| while 循环（条件为真时执行） | while [[条件]]; do 命令；done               | `i=1; while [[ $i -le 3 ]]; do echo $i; i=$((i+1)); done`（输出 1 2 3） |
| until 循环（条件为假时执行） | until [[条件]]; do 命令；done               | `i=1; until [[ $i -gt 3 ]]; do echo $i; i=$((i+1)); done`（输出 1 2 3） |
| 循环控制                     | break（跳出循环）；continue（跳过本次循环） | `for i in 1 2 3; do if [[ $i -eq 2 ]]; then break; fi; echo $i; done`（输出 1） |

### 六、函数

| 操作类型   | 语法 / 说明                                      | 示例（单行简化）                                             |
| ---------- | ------------------------------------------------ | ------------------------------------------------------------ |
| 定义函数   | 函数名 () { 命令；} 或 function 函数名 { 命令；} | `hello() { echo "Hello"; }`                                  |
| 调用函数   | 函数名 [参数]                                    | `hello`（执行后输出 Hello）                                  |
| 函数传参   | 函数内用$1、$2... 获取参数                       | `sum() { echo $(( $1 + $2 )); }; sum 3 5`（输出 8）          |
| 函数返回值 | return 数字（0-255）；或用 echo 输出结果         | `get_name() { echo "shell"; }; name=$(get_name)`（变量 name 赋值为 shell） |

### 七、常用工具（脚本中高频使用）

| 工具 | 作用                 | 示例（脚本中使用）                                           |                            |
| ---- | -------------------- | ------------------------------------------------------------ | -------------------------- |
| grep | 文本搜索             | `grep "error" app.log`（查找日志中的 error）                 |                            |
| awk  | 文本分析（按列处理） | `awk '{print $1}' data.txt`（输出第一列内容）                |                            |
| sed  | 文本替换             | `sed -i 's/old/new/g' file.txt`（替换文件中所有 old 为 new） |                            |
| find | 查找文件             | `find /home -name "*.sh"`（查找 /home 下的.sh 文件）         |                            |
| cut  | 截取文本列           | `echo "a,b,c"                                                | cut -d ',' -f 2`（输出 b） |

### 学习建议：

1. 从简单脚本入手（如输出 Hello World、批量创建文件），逐步增加逻辑（条件、循环）；
2. 多实践：用脚本解决实际问题（如日志清理、批量备份）；
3. 善用`man bash`查看官方文档，或**通过`echo $?`查看命令执行结果（0 为成功，非 0 为失败）**。

通过以上表格的知识点，可快速掌握 Shell 脚本的核心语法，后续结合实践即可熟练应用。



## 常见场景

以下是Shell脚本在服务器测试中的**常见应用场景、用法及示例**，结合测试实际需求整理，方便直接参考使用：


以下是在原表格基础上新增“代码解释”列后的完整表格，详细说明每个示例脚本的核心逻辑和命令含义：


| 应用场景                | 常见用法                          | 示例脚本（单行/简短片段）                                                                 | 测试中的作用                                                                 | 代码解释                                                                 |
|-------------------------|-----------------------------------|------------------------------------------------------------------------------------------|------------------------------------------------------------------------------|--------------------------------------------------------------------------|
| **服务状态自动检查**    | 结合`systemctl`/`ps`判断服务是否运行，异常时报警 | `if ! systemctl is-active --quiet nginx; then echo "nginx down"; fi`                     | 定时巡检服务存活状态（如Web服务、数据库），快速发现服务宕机                   | `systemctl is-active --quiet nginx`：安静模式检查nginx是否活跃（返回0为正常）；`!`取反表示“若服务不活跃”，则输出“nginx down” |
| **日志错误分析**        | 用`grep`/`awk`筛选日志中的错误、超时等关键字 | `grep -c "ERROR" /var/log/app.log` 或 `awk '/Timeout/ {print $0}' /var/log/api.log`     | 统计测试过程中错误出现次数，定位接口超时、服务异常等问题                       | `grep -c "ERROR"`：统计日志中含“ERROR”的行数（错误总数）；`awk '/Timeout/ {print $0}'`：匹配含“Timeout”的行并打印完整内容 |
| **性能指标监控**        | 提取`top`/`free`/`df`的关键指标（CPU、内存、磁盘） | `top -bn1 | grep "Cpu(s)" | awk '{print "CPU使用率：" $2 "%"}'`                         | 持续监控服务器负载，判断测试用例是否导致资源耗尽（如内存泄漏、CPU飙升）       | `top -bn1`：非交互模式获取一次系统状态；`grep "Cpu(s)"`筛选CPU信息行；`awk`提取第二列（用户态CPU使用率）并格式化输出 |
| **批量执行测试命令**    | 用`for`循环批量操作多台服务器或多端口 | `for port in 8080 8081 8082; do curl http://localhost:$port/health; done`                | 同时测试多个服务实例（如集群节点、多端口部署的服务）的可用性                   | `for`循环遍历8080/8081/8082端口；`curl`访问每个端口的健康检查接口，批量验证服务是否响应 |
| **测试环境初始化**      | 自动创建目录、配置文件、授权等     | `mkdir -p /test/logs && chmod 777 /test/logs && touch /test/config.ini`                   | 标准化测试环境准备流程，避免手动操作遗漏（如日志目录权限不足导致测试失败）     | `mkdir -p`：递归创建/test/logs（父目录不存在则自动创建）；`chmod 777`：赋予读写执行权限；`touch`：创建空配置文件，通过`&&`确保步骤依次执行 |
| **测试数据生成**        | 用`shuf`/`date`生成随机数、时间等测试数据 | `for i in {1..10}; do echo "user$i,age=$(shuf -i 18-60 -n1)" >> testdata.csv; done`      | 快速生成批量测试数据（如用户信息、订单数据），用于接口压力测试                 | `for`循环生成1-10的序号；`shuf -i 18-60 -n1`：生成18-60的随机数作为年龄；`>>`将“userX,age=Y”追加到CSV文件 |
| **磁盘空间预警**        | 检查磁盘使用率，超过阈值时提醒     | `if [[ $(df -h / | awk 'NR==2 {print $5}' | sed 's/%//') -gt 80 ]]; then echo "磁盘满"; fi` | 避免测试过程中因磁盘空间不足（如日志过大）导致服务崩溃                       | `df -h /`：查看根目录磁盘信息；`awk 'NR==2 {print $5}'`提取第二行第五列（使用率，如“85%”）；`sed 's/%//'`去除百分号；判断数值是否超过80，是则提示 |
| **接口响应时间测试**    | 用`curl`+`time`统计接口耗时        | `time curl -s http://localhost/api/login > /dev/null`                                    | 评估接口性能，判断响应时间是否符合测试标准（如是否超过1秒）                   | `time`：统计后续命令执行耗时；`curl -s`：静默模式访问接口；`> /dev/null`：屏蔽接口输出，只关注耗时 |
| **测试结果汇总**        | 收集多维度测试结果，输出报告格式   | `echo "测试时间：$(date)"; echo "错误数：$(grep -c ERROR log.txt)"; echo "CPU峰值：$(cat cpu.log | sort -nr | head -1)"` | 自动化生成测试简报，汇总关键指标（错误数、资源峰值等）                       | `$(date)`：插入当前时间；`$(grep -c ERROR log.txt)`：插入错误总数；`$(cat cpu.log | sort -nr | head -1)`：从cpu.log中提取最大值（CPU峰值），通过`echo`组合成报告 |
| **进程资源限制检查**    | 用`ps`+`awk`查看进程CPU/内存占用是否超限 | `ps aux | grep python | awk '$3 > 50 {print "进程" $2 "CPU超限：" $3 "%"}'`              | 发现测试中异常占用资源的进程（如某个测试用例导致进程CPU使用率超过50%）         | `ps aux`：获取所有进程详情；`grep python`：筛选Python进程；`awk '$3 > 50 {print...}'`：判断第三列（CPU使用率）是否超50%，是则打印进程PID和超限值 |


### 实战说明：  
1. **自动化巡检脚本**：将上述场景组合，可编写定时任务（通过`crontab`），例如每5分钟检查服务状态+磁盘空间+错误日志，异常时发送邮件报警（结合`mail`命令）。  
   ```bash
   # 示例：简单巡检脚本 check_server.sh
   #!/bin/bash
   result="$(date)\n"
   # 检查nginx状态
   if ! systemctl is-active --quiet nginx; then result+="nginx服务异常\n"; fi
   # 检查磁盘空间
   if [[ $(df -h / | awk 'NR==2 {print $5}' | sed 's/%//') -gt 80 ]]; then result+="根目录磁盘使用率超80%\n"; fi
   # 输出结果（可扩展为发送邮件）
   echo -e $result
   ```
   用`crontab -e`添加定时任务：`*/5 * * * * /path/check_server.sh >> /test/check.log`  

2. **日志实时监控**：用`tail -f`结合`grep`实时捕捉测试中的错误，触发预警。  
   ```bash
   tail -f /var/log/app.log | grep --line-buffered "FATAL" | while read line; do echo "致命错误：$line" | mail -s "测试报警" admin@example.com; done
   ```


这些用法的核心是**将重复的手动检查逻辑自动化**，提高服务器测试的效率和准确性，尤其适合回归测试、压力测试等需要持续监控的场景。

以下结合服务器测试的核心场景，提供**详细的Shell脚本示例**，并逐行解释代码逻辑，帮助理解其在测试中的实际作用：


### 场景1：服务健康自动巡检（核心场景）  
**测试目的**：定时检查服务是否存活、端口是否监听、接口是否正常响应，避免人工巡检遗漏问题。  


#### 脚本：`check_service_health.sh`  
```bash
#!/bin/bash
# 服务健康巡检脚本：检查nginx服务状态、80端口监听、首页响应
# 测试用途：用于Web服务稳定性测试，每5分钟执行一次，异常时记录日志并报警

# 定义参数（方便后续修改）
SERVICE_NAME="nginx"       # 目标服务名
PORT=80                    # 服务监听端口
CHECK_URL="http://localhost"  # 健康检查接口
LOG_FILE="/var/log/service_health.log"  # 巡检日志路径

# 1. 检查服务是否运行
if ! systemctl is-active --quiet $SERVICE_NAME; then
    # 服务未运行：记录日志
    echo "[$(date +'%Y-%m-%d %H:%M:%S')] 错误：$SERVICE_NAME 服务未运行" >> $LOG_FILE
    exit 1  # 退出码1表示异常
fi

# 2. 检查端口是否监听（避免服务假死，进程存在但端口未监听）
if ! ss -tuln | grep -q ":$PORT"; then  # ss替代netstat，更高效；-q静默模式
    echo "[$(date +'%Y-%m-%d %H:%M:%S')] 错误：$SERVICE_NAME 未监听端口 $PORT" >> $LOG_FILE
    exit 1
fi

# 3. 检查接口是否正常响应（状态码200）
# curl参数：-s静默模式；-o输出到/dev/null；-w只打印状态码
HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" $CHECK_URL)
if [ $HTTP_CODE -ne 200 ]; then
    echo "[$(date +'%Y-%m-%d %H:%M:%S')] 错误：$CHECK_URL 响应状态码为 $HTTP_CODE" >> $LOG_FILE
    exit 1
fi

# 4. 所有检查通过：记录正常日志
echo "[$(date +'%Y-%m-%d %H:%M:%S')] $SERVICE_NAME 服务健康" >> $LOG_FILE
exit 0  # 退出码0表示正常
```


#### 代码解释：  
1. **参数定义**：将服务名、端口、日志路径等定义为变量，后续修改无需改逻辑，适配不同服务（如替换为`mysql`和3306端口）。  
2. **服务状态检查**：`systemctl is-active --quiet $SERVICE_NAME`：安静模式检查服务是否活跃（返回0为正常，非0为异常），`!`取反表示“如果服务不活跃”。  
3. **端口监听检查**：`ss -tuln`列出所有监听的TCP/UDP端口（`-t`TCP，`-u`UDP，`-l`监听中，`-n`数字显示端口）；`grep -q ":$PORT"`静默检查是否包含目标端口，避免输出冗余信息。  
4. **接口响应检查**：`curl`的`-w "%{http_code}"`仅返回HTTP状态码，通过判断是否为200确认接口正常（测试中常用200作为“健康”标准）。  
5. **日志记录**：用`date +'%Y-%m-%d %H:%M:%S'`添加时间戳，方便追溯问题发生时间；异常时`exit 1`，可结合`crontab`定时执行并触发报警（如邮件）。  


### 场景2：测试日志错误统计与分析  
**测试目的**：从测试产生的日志中提取错误信息、统计频次，定位高频失败的测试用例或服务漏洞。  


#### 脚本：`analyze_test_log.sh`  
```bash
#!/bin/bash
# 日志分析脚本：统计ERROR级别日志、提取最近1小时错误、按模块分组
# 测试用途：用于功能测试后分析日志，快速定位哪类操作错误最多

# 定义参数
LOG_PATH="/var/log/test_app.log"  # 测试日志文件
OUTPUT_FILE="/tmp/log_analysis.txt"  # 分析结果输出路径

# 1. 统计总ERROR次数
ERROR_COUNT=$(grep -c "ERROR" $LOG_PATH)  # -c统计匹配行数

# 2. 提取最近1小时内的ERROR日志（假设日志格式含"2025-10-13 10:00:00"时间戳）
# 先获取1小时前的时间（格式与日志一致）
ONE_HOUR_AGO=$(date -d '1 hour ago' +'%Y-%m-%d %H:%M:%S')
# 用awk筛选时间戳晚于ONE_HOUR_AGO的ERROR日志
RECENT_ERRORS=$(awk -v t="$ONE_HOUR_AGO" '$0 ~ "ERROR" && $1 " " $2 > t' $LOG_PATH)

# 3. 按模块分组统计错误（假设日志格式："2025-10-13 10:00:00 [模块A] ERROR: ..."）
MODULE_ERRORS=$(grep "ERROR" $LOG_PATH | awk -F '\\[|\\]' '{print $2}' | sort | uniq -c)
# -F '\\[|\\]'：以[或]为分隔符，$2提取模块名；sort+uniq -c统计每个模块的错误次数

# 4. 输出分析结果
echo "===== 测试日志分析报告（$(date)） =====" > $OUTPUT_FILE
echo "1. 总ERROR次数：$ERROR_COUNT" >> $OUTPUT_FILE
echo -e "\n2. 最近1小时ERROR日志：" >> $OUTPUT_FILE
echo "$RECENT_ERRORS" >> $OUTPUT_FILE
echo -e "\n3. 按模块错误统计：" >> $OUTPUT_FILE
echo "$MODULE_ERRORS" >> $OUTPUT_FILE

# 打印提示
echo "分析完成，结果已保存至 $OUTPUT_FILE"
```


#### 代码解释：  
1. **错误次数统计**：`grep -c "ERROR" $LOG_PATH`：`-c`直接返回包含“ERROR”的行数，即错误总次数（测试中用于判断整体稳定性）。  
2. **时间筛选**：`date -d '1 hour ago'`生成1小时前的时间，`awk`通过比较日志中的时间戳（假设前两列为`日期 时间`），筛选最近1小时的错误（测试中重点关注“刚发生的新错误”）。  
3. **模块分组统计**：`awk -F '\\[|\\]' '{print $2}'`：以`[`或`]`为分隔符，提取日志中的模块名（如`[模块A]`中的“模块A”）；`sort | uniq -c`统计每个模块的错误频次（帮助定位“哪个模块问题最多”）。  
4. **报告输出**：将结果写入文件，方便测试人员后续分析（如结合测试用例，确认是否某模块的用例设计有问题）。  


### 场景3：服务器性能指标监控（压力测试辅助）  
**测试目的**：在压力测试过程中，实时记录CPU、内存、磁盘IO等指标，判断服务在高负载下的性能瓶颈。  


#### 脚本：`monitor_performance.sh`  
```bash
#!/bin/bash
# 性能监控脚本：每5秒记录一次CPU、内存、磁盘IO，持续10分钟
# 测试用途：配合压力测试（如ab、jmeter），记录资源变化趋势

# 定义参数
DURATION=600  # 监控持续时间（秒），10分钟=600秒
INTERVAL=5    # 采样间隔（秒）
OUTPUT_FILE="/tmp/performance_monitor.csv"  # 结果文件（CSV格式，方便Excel分析）

# 写入CSV表头
echo "时间,CPU使用率(%),内存使用率(%),磁盘IO使用率(%)" > $OUTPUT_FILE

# 计算结束时间（当前时间+持续时间）
END_TIME=$(( $(date +%s) + DURATION ))

# 循环监控
while [ $(date +%s) -lt $END_TIME ]; do
    # 1. 获取CPU使用率（%user + %system，排除idle）
    CPU_USAGE=$(top -bn1 | grep "Cpu(s)" | awk '{printf "%.1f", 100 - $8}')
    # top -bn1：非交互模式执行一次；$8是%idle，100-$8即总使用率

    # 2. 获取内存使用率（已用/总内存）
    MEM_TOTAL=$(free -m | awk 'NR==2 {print $2}')  # 总内存（MB）
    MEM_USED=$(free -m | awk 'NR==2 {print $3}')   # 已用内存（MB）
    MEM_USAGE=$(echo "scale=1; $MEM_USED / $MEM_TOTAL * 100" | bc)  # 计算百分比

    # 3. 获取磁盘IO使用率（%util，设备忙碌时间占比）
    DISK_IO=$(iostat -x 1 1 | awk 'NR==4 {printf "%.1f", $14}')  # 假设第一块磁盘是sda
    # iostat -x 1 1：显示详细IO，1秒采样1次；$14是%util（设备利用率）

    # 4. 记录当前时间和指标
    CURRENT_TIME=$(date +'%Y-%m-%d %H:%M:%S')
    echo "$CURRENT_TIME,$CPU_USAGE,$MEM_USAGE,$DISK_IO" >> $OUTPUT_FILE

    # 等待采样间隔
    sleep $INTERVAL
done

echo "监控结束，结果已保存至 $OUTPUT_FILE（可用Excel打开分析趋势）"
```


#### 代码解释：  
1. **监控周期控制**：通过`END_TIME`计算监控结束的时间戳，`while`循环在当前时间小于`END_TIME`时持续运行（适配压力测试的固定时长）。  
2. **CPU使用率计算**：`top -bn1`非交互模式获取系统状态，`grep "Cpu(s)"`提取CPU行，`$8`是空闲率（%idle），`100-$8`即为实际使用率（测试中需关注是否超过80%阈值）。  
3. **内存使用率计算**：`free -m`以MB为单位显示内存，`NR==2`提取第二行（内存数据），`$2`是总内存，`$3`是已用内存，通过`bc`计算百分比（判断是否有内存泄漏）。  
4. **磁盘IO使用率**：`iostat -x`显示详细IO统计，`%util`（$14）表示设备忙碌时间占比（超过100%说明有IO等待，是性能瓶颈）。  
5. **CSV格式输出**：结果按时间+指标格式保存，方便用Excel生成折线图，直观查看压力测试过程中资源变化趋势（如“并发1000时CPU飙升至90%”）。  


### 场景4：测试环境一键初始化  
**测试目的**：标准化测试环境配置，避免因环境不一致导致的测试结果偏差（如目录权限、依赖包、配置文件错误）。  


#### 脚本：`init_test_env.sh`  
```bash
#!/bin/bash
# 测试环境初始化脚本：创建目录、安装依赖、配置权限、启动基础服务
# 测试用途：新服务器部署测试环境时使用，确保每次环境一致

# 定义参数
TEST_DIR="/opt/test_env"  # 测试主目录
LOG_DIR="$TEST_DIR/logs"  # 日志目录
CONFIG_DIR="$TEST_DIR/config"  # 配置文件目录
DEPENDENCIES="nginx python3-pip"  # 依赖软件

# 1. 创建必要目录
echo "创建测试目录..."
mkdir -p $TEST_DIR $LOG_DIR $CONFIG_DIR  # -p确保父目录不存在时自动创建

# 2. 设置目录权限（测试服务通常需要读写权限）
chown -R testuser:testgroup $TEST_DIR  # 授权给测试专用用户
chmod -R 755 $TEST_DIR  # 所有者读写执行，其他读执行

# 3. 安装依赖软件
echo "安装依赖..."
apt update -y  # 更新包索引（适用于Debian/Ubuntu）
apt install -y $DEPENDENCIES  # -y自动确认安装

# 4. 复制配置文件（假设本地有预设的配置模板）
echo "配置服务..."
cp ./nginx_test.conf $CONFIG_DIR/  # 复制测试专用nginx配置
ln -s $CONFIG_DIR/nginx_test.conf /etc/nginx/conf.d/  # 创建软链接到nginx配置目录

# 5. 启动基础服务并设置开机自启
systemctl start nginx
systemctl enable nginx

# 6. 验证初始化结果
if [ -d $TEST_DIR ] && systemctl is-active --quiet nginx; then
    echo "环境初始化成功！测试目录：$TEST_DIR"
else
    echo "初始化失败，请检查错误日志"
    exit 1
fi
```


#### 代码解释：  
1. **目录创建**：`mkdir -p`批量创建嵌套目录（如`/opt/test_env/logs`），避免手动逐个创建的繁琐。  
2. **权限配置**：`chown`指定测试用户/组，`chmod 755`确保目录可读写（测试中服务常因权限不足导致启动失败，此步骤是关键）。  
3. **依赖安装**：通过`apt`一键安装测试必需的软件（如nginx作为测试服务器，python3-pip用于安装测试工具），`-y`参数避免手动确认，适合自动化。  
4. **配置文件部署**：复制预设的测试配置（如nginx的测试端口、日志路径），通过软链接（`ln -s`）关联到系统配置目录，方便后续修改模板。  
5. **服务启动与验证**：启动服务并设置自启，最后通过目录存在性和服务状态判断初始化是否成功（确保测试环境可用）。  


### 总结  
这些脚本在服务器测试中的核心价值是**自动化重复操作、标准化测试过程、量化测试数据**：  
- 健康巡检脚本 → 替代人工定时查服务，及时发现异常；  
- 日志分析脚本 → 快速定位测试中的高频错误，提高问题排查效率；  
- 性能监控脚本 → 为压力测试提供客观的资源指标，支撑性能瓶颈分析；  
- 环境初始化脚本 → 确保每次测试在相同环境中进行，避免“环境不一致导致的测试结果不可靠”。  

实际使用时，可根据测试目标（如数据库测试、API测试）修改脚本中的服务名、端口、日志格式等参数，灵活适配不同场景。

日常工作和生活中，Shell脚本常用于**自动化重复操作、简化复杂任务**，以下是按场景分类的常用脚本，附核心代码和用途说明，可直接复用或修改：


### 一、文件管理类（高频使用）  
#### 1. 批量重命名文件（如统一后缀、添加前缀）  
**用途**：整理照片、文档时，批量修改文件名（如将`img1.jpg`→`vacation_2024_img1.jpg`）。  
```bash
#!/bin/bash
# 批量给当前目录的.jpg文件添加前缀"vacation_"
prefix="vacation_"
for file in *.jpg; do
    if [ -f "$file" ]; then  # 只处理文件（排除目录）
        mv -- "$file" "${prefix}${file}"  # -- 避免文件名以-开头导致错误
    fi
done
echo "重命名完成！"
```


#### 2. 查找并清理大文件（释放磁盘空间）  
**用途**：快速定位占用空间大的文件（如日志、缓存），避免磁盘满。  
```bash
#!/bin/bash
# 查找/home目录下大于100MB的文件，按大小排序
echo "查找/home下大于100MB的文件："
find /home -type f -size +100M -exec du -h {} \; | sort -hr  # -h人类可读，-r倒序

# 可选：删除确认（谨慎使用！）
read -p "是否删除上述文件？(y/n) " choice
if [ "$choice" = "y" ]; then
    find /home -type f -size +100M -exec rm -i {} \;  # -i删除前确认
fi
```


#### 3. 批量压缩指定目录（备份归档）  
**用途**：定期压缩日志、文档目录（如每天压缩`/var/log`，避免占用空间）。  
```bash
#!/bin/bash
# 压缩/var/log目录，以日期命名（如log_20241013.tar.gz）
src_dir="/var/log"
backup_name="log_$(date +%Y%m%d).tar.gz"  # 日期作为文件名，避免重复

tar -czf "$backup_name" "$src_dir"  # -c创建，-z压缩，-f指定文件名
if [ $? -eq 0 ]; then  # $?是上条命令的退出码（0为成功）
    echo "压缩成功：$backup_name"
else
    echo "压缩失败！"
fi
```


### 二、系统维护类（服务器/个人电脑通用）  
#### 1. 自动清理系统缓存（释放内存）  
**用途**：Linux系统缓存过高时，手动清理（适用于内存紧张场景）。  
```bash
#!/bin/bash
# 清理页缓存、目录项和inode缓存（需要root权限）
echo "清理前内存使用："
free -h

sudo sync  # 先同步数据到磁盘，避免数据丢失
sudo echo 3 > /proc/sys/vm/drop_caches  # 3表示清理所有缓存

echo "清理后内存使用："
free -h
```
**说明**：`/proc/sys/vm/drop_caches`值：1=页缓存，2=目录项和inode，3=全部。  


#### 2. 定时备份重要文件（防丢失）  
**用途**：自动备份配置文件、文档到本地或远程（结合`crontab`定时执行）。  
```bash
#!/bin/bash
# 备份/home/user/documents到/backup，保留最近7天的备份
src="/home/user/documents"
dest="/backup"
backup_file="${dest}/doc_backup_$(date +%Y%m%d).tar.gz"

# 创建备份目录（若不存在）
mkdir -p "$dest"

# 压缩备份
tar -czf "$backup_file" "$src"

# 删除7天前的旧备份（只保留最近7天）
find "$dest" -name "doc_backup_*.tar.gz" -mtime +7 -delete

echo "备份完成：$backup_file"
```
**定时执行**：`crontab -e`添加 `0 2 * * * /path/backup_doc.sh`（每天凌晨2点执行）。  


#### 3. 检查系统健康状态（快速排查问题）  
**用途**：一键查看CPU、内存、磁盘、进程状态（替代手动敲多个命令）。  
```bash
#!/bin/bash
echo "===== 系统健康检查（$(date)） ====="
echo "1. CPU使用率："
top -bn1 | grep "Cpu(s)" | awk '{printf "总使用率：%.1f%%\n", 100 - $8}'

echo -e "\n2. 内存使用："
free -h | awk 'NR==2 {print "已用/总内存：" $3 "/" $2 "（使用率：" $3/$2*100 "%" "）"}'

echo -e "\n3. 磁盘使用率（根目录）："
df -h / | awk 'NR==2 {print $5 " 已用"}'

echo -e "\n4. 占用CPU最高的3个进程："
ps aux --sort=-%cpu | head -4 | awk '{print $1, $2, $3 "%", $11}'  # 用户、PID、CPU%、进程名
```


### 三、开发辅助类（程序员常用）  
#### 1. 统计代码行数（按文件类型）  
**用途**：快速统计项目中不同类型文件的代码行数（如Python、Java文件）。  
```bash
#!/bin/bash
# 统计当前目录下.py和.java文件的总行数
echo "Python文件行数："
find . -name "*.py" -type f -exec cat {} \; | wc -l  # 递归查找所有.py，合并后统计行数

echo "Java文件行数："
find . -name "*.java" -type f -exec cat {} \; | wc -l
```


#### 2. 启动开发环境（一键启动多服务）  
**用途**：开发时需同时启动数据库、后端服务、前端服务，避免手动逐个启动。  
```bash
#!/bin/bash
# 一键启动MySQL、后端API、前端服务（在不同终端窗口运行）
echo "启动MySQL..."
sudo systemctl start mysql

echo "启动后端API（端口8000）..."
cd /path/to/backend && python3 main.py &  # & 后台运行

echo "启动前端服务（端口3000）..."
cd /path/to/frontend && npm run dev &

echo "所有服务启动完成！"
```


#### 3. 批量替换文件内容（代码重构）  
**用途**：重构时批量替换多个文件中的旧关键词（如将`old_func`替换为`new_func`）。  
```bash
#!/bin/bash
# 在当前目录所有.py文件中，替换"old_func"为"new_func"（备份原文件）
old_str="old_func"
new_str="new_func"

# 递归替换，-i.bak保留备份文件（替换后可删除.bak）
grep -rl "$old_str" ./ --include="*.py" | xargs sed -i.bak "s/$old_str/$new_str/g"

echo "替换完成！原文件备份为.bak"
# 可选：删除备份（确认替换正确后）
# find . -name "*.bak" -delete
```


### 四、日常办公类（提高效率）  
#### 1. 批量发送邮件（通知、报表）  
**用途**：自动发送日报、通知给团队（需系统安装`mailutils`）。  
```bash
#!/bin/bash
# 发送带附件的邮件给团队（主题+内容+附件）
subject="今日测试报告（$(date +%Y-%m-%d)）"
content="请查收今日测试结果，详见附件。"
recipient="team@example.com"  # 收件人邮箱
attachment="/path/to/report.pdf"  # 附件路径

echo "$content" | mail -s "$subject" -a "$attachment" "$recipient"
echo "邮件发送完成！"
```


#### 2. 生成随机密码（安全设置）  
**用途**：注册账号或配置服务时，生成高强度随机密码（字母+数字+特殊字符）。  
```bash
#!/bin/bash
# 生成12位随机密码（包含大小写字母、数字、特殊字符）
password=$(tr -dc 'A-Za-z0-9!@#$%^&*()_+' < /dev/urandom | head -c 12)
echo "生成的随机密码：$password"
```


### 总结  
这些脚本的核心是**“将重复操作写成固定逻辑”**，减少手动操作的时间和错误。日常使用时，可根据需求修改路径、参数或逻辑（比如调整备份目录、替换关键词），搭配`crontab`实现定时任务（如每日备份、每周清理），进一步提升效率。