---
layout: post
title:  "正则表达式"
date:   2025-09-13 12:11:00 +0800
categories: 计算机基础
tags: 正则表达式  
author: PandHedge
mathjax: true
---

* content
{:toc}


## 正则表达式

正则表达式是一种用于匹配和操作文本的强大工具，它是由一系列字符和特殊字符组成的模式，用于描述要匹配的文本模式。

正则表达式可以在文本中查找、替换、提取和验证特定的模式。



### 正则表达式 语法

- **runoo+b**，可以匹配 **runoob、runooob、runoooooob** 等，**+** 号代表前面的字符必须至少出现一次（1次或多次）
- **runoo\*b**，可以匹配 **runob、runoob、runoooooob** 等，***** 号代表前面的字符可以不出现，也可以出现一次或者多次（0次、或1次、或多次）
- **colou?r** 可以匹配 **color** 或者 **colour**，**?** 问号代表前面的字符最多只可以出现一次（0次或1次）

#### 普通字符

普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。

| 字符       | 描述                                                         |
| :--------- | :----------------------------------------------------------- |
| **[ABC]**  | 匹配 **[...]** 中的所有字符，例如 **[aeiou]** 匹配字符串 "google runoob taobao" 中所有的 e o u a 字母。![img](https://www.runoob.com/wp-content/uploads/2014/03/E691DDE1-E5CB-4EA8-8D16-759BD0D2B09D.jpg) |
| **[^ABC]** | 匹配除了 **[...]** 中字符的所有字符，例如 **[^aeiou]** 匹配字符串 "google runoob taobao" 中除了 e o u a 字母的所有字符。![img](https://www.runoob.com/wp-content/uploads/2014/03/ED971D92-30F4-4768-A2C7-02A84A3A9DEB.jpg) |
| **[A-Z]**  | [A-Z] 表示一个区间，匹配所有大写字母，[a-z] 表示所有小写字母。![img](https://www.runoob.com/wp-content/uploads/2014/03/C5E357BD-65E3-4EB3-9D80-10D096F19287.jpg) |
| **.**      | 匹配除换行符（\n、\r）之外的任何单个字符，相等于 [^\n\r]。![img](https://www.runoob.com/wp-content/uploads/2014/03/0FD7E77D-38A7-43BC-B51A-7DBA23A77756.jpg) |
| **[\s\S]** | 匹配所有。\s 是匹配所有空白符，包括换行，\S 非空白符，不包括换行。![img](https://www.runoob.com/wp-content/uploads/2014/03/47CA6C59-64CF-433A-909E-1E342349A4E0.jpg) |
| **\w**     | 匹配字母、数字、下划线。等价于 [A-Za-z0-9_]![img](https://www.runoob.com/wp-content/uploads/2014/03/F35A5971-3519-4CAE-8BEC-9DE8F4A55257.jpg) |
| **\d**     | 匹配任意一个阿拉伯数字（0 到 9）。等价于 **[0-9]**![img](https://www.runoob.com/wp-content/uploads/2014/03/20f5a98835b67f6159d11.png) |

#### 非打印字符

非打印字符也可以是正则表达式的组成部分。下表列出了表示非打印字符的转义序列：

| 字符 | 描述                                                         |
| :--- | :----------------------------------------------------------- |
| \cx  | 匹配由x指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 'c' 字符。 |
| \f   | 匹配一个换页符。等价于 \x0c 和 \cL。                         |
| \n   | 匹配一个换行符。等价于 \x0a 和 \cJ。                         |
| \r   | 匹配一个回车符。等价于 \x0d 和 \cM。                         |
| \s   | 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。注意 Unicode 正则表达式会匹配全角空格符。 |
| \S   | 匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。                  |
| \t   | 匹配一个制表符。等价于 \x09 和 \cI。                         |
| \v   | 匹配一个垂直制表符。等价于 \x0b 和 \cK。                     |

#### 特殊字符

所谓特殊字符，就是一些有特殊含义的字符，如上面说的 **runoo\*b** 中的 *****，简单的说就是表示任何字符串的意思。如果要查找字符串中的 ***** 符号，则需要对 ***** 进行转义，即在其前加一个 **\**，**runo\*ob** 匹配字符串 **runo\*ob**。

许多元字符要求在试图匹配它们时特别对待。若要匹配这些特殊字符，必须首先使字符"转义"，即，将反斜杠字符**\** 放在它们前面。下表列出了正则表达式中的特殊字符：

| 特别字符 | 描述                                                         |
| :------- | :----------------------------------------------------------- |
| $        | 匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 '\n' 或 '\r'。要匹配 $ 字符本身，请使用 `\$`。 |
| ( )      | 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 \( 和 \)。 |
| *        | 匹配前面的子表达式零次或多次。要匹配 * 字符，请使用` \*`。   |
| +        | 匹配前面的子表达式一次或多次。要匹配 + 字符，请使用` \+`。   |
| .        | 匹配除换行符 \n 之外的任何单字符。要匹配 . ，请使用` \.` 。  |
| [        | 标记一个中括号表达式的开始。要匹配 [，请使用` \[`。          |
| ?        | 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 \?。 |
| \        | 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， 'n' 匹配字符 'n'。'\n' 匹配换行符。序列 '\\' 匹配 "\"，而 '\(' 则匹配 "("。 |
| ^        | 匹配输入字符串的开始位置，除非在方括号表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。要匹配 ^ 字符本身，请使用 \^。 |
| {        | 标记限定符表达式的开始。要匹配 {，请使用 \{。                |
| \|       | 指明两项之间的一个选择。要匹配 \|，请使用 \|。               |

#### 限定符

限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 ***** 或 **+** 或 **?** 或 **{n}** 或 **{n,}** 或 **{n,m}** 共6种。

正则表达式的限定符有：

| 字符  | 描述                                                         |
| :---- | :----------------------------------------------------------- |
| *     | 匹配前面的子表达式零次或多次。例如，**zo\*** 能匹配 **"z"** 以及 **"zoo"**。***** 等价于 **{0,}**。 |
| +     | 匹配前面的子表达式一次或多次。例如，**zo+** 能匹配 **"zo"** 以及 "**zoo"**，但不能匹配 **"z"**。**+** 等价于 **{1,}**。 |
| ?     | 匹配前面的子表达式零次或一次。例如，**do(es)?** 可以匹配 **"do"** 、 **"does"**、 **"doxy"** 中的 **"do"** 和 **"does"**。**?** 等价于 **{0,1}**。![img](https://www.runoob.com/wp-content/uploads/2014/03/CA742DA3-826D-463B-85F5-316DAB3515C1.jpeg) |
| {n}   | n 是一个非负整数。匹配确定的 **n** 次。例如，**o{2}** 不能匹配 **"Bob"** 中的 **o**，但是能匹配 **"food"** 中的两个 **o**。 |
| {n,}  | n 是一个非负整数。至少匹配n 次。例如，**o{2,}** 不能匹配 **"Bob"** 中的 **o**，但能匹配 **"foooood"** 中的所有 **o**。**o{1,}** 等价于 **o+**。**o{0,}** 则等价于 **o\***。 |
| {n,m} | m 和 n 均为非负整数，其中 n <= m。最少匹配 n 次且最多匹配 m 次。例如，**o{1,3}** 将匹配 **"fooooood"** 中的前三个 **o**。**o{0,1}** 等价于 **o?**。请注意在逗号和两个数之间不能有空格。 |

#### 定位符

定位符使您能够将正则表达式固定到行首或行尾。它们还使您能够创建这样的正则表达式，这些正则表达式出现在一个单词内、在一个单词的开头或者一个单词的结尾。

定位符用来描述字符串或单词的边界，**^** 和 **$** 分别指字符串的开始与结束，**\b** 描述单词的前或后边界，**\B** 表示非单词边界。

正则表达式的定位符有：

| 字符 | 描述                                                         |
| :--- | :----------------------------------------------------------- |
| ^    | 匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \n 或 \r 之后的位置匹配。 |
| $    | 匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \n 或 \r 之前的位置匹配。 |
| \b   | 匹配一个单词边界，即字与空格间的位置。                       |
| \B   | 非单词边界匹配。                                             |

**注意**：不能将限定符与定位符一起使用。由于在紧靠换行或者单词边界的前面或后面不能有一个以上位置，因此不允许诸如 **^\*** 之类的表达式。

若要匹配一行文本开始处的文本，请在正则表达式的开始使用 **^** 字符。不要将 **^** 的这种用法与中括号表达式内的用法混淆。

若要匹配一行文本的结束处的文本，请在正则表达式的结束处使用 **$** 字符。

```
/(\w+):\/\/([^/:]+)(:\d*)?([^# ]*)/

var str = "https://www.runoob.com:80/html/html-tutorial.html";
var patt1 = /(\w+):\/\/([^/:]+)(:\d*)?([^# ]*)/;

第三行代码 str.match(patt1) 返回一个数组，实例中的数组包含 5 个元素，索引 0 对应的是整个字符串，索引 1 对应第一个匹配符（括号内），以此类推。

第一个括号子表达式捕获 Web 地址的协议部分。该子表达式匹配在冒号和两个正斜杠前面的任何单词。

第二个括号子表达式捕获地址的域地址部分。子表达式匹配非 : 和 / 之后的一个或多个字符。

第三个括号子表达式捕获端口号（如果指定了的话）。该子表达式匹配冒号后面的零个或多个数字。只能重复一次该子表达式。

最后，第四个括号子表达式捕获 Web 地址指定的路径和 / 或页信息。该子表达式能匹配不包括 # 或空格字符的任何字符序列。

将正则表达式应用到上面的 URI，各子匹配项包含下面的内容：

第一个括号子表达式包含 https
第二个括号子表达式包含 www.runoob.com
第三个括号子表达式包含 :80
第四个括号子表达式包含 /html/html-tutorial.html
```





#### 选择

用圆括号 **()** 将所有选择项括起来，相邻的选择项之间用 **|** 分隔。

**()** 表示捕获分组，**()** 会把每个分组里的匹配的值保存起来， 多个匹配值可以通过数字 n 来查看(**n** 是一个数字，表示第 n 个捕获组的内容)。

但用圆括号会有一个副作用，使相关的匹配会被缓存，此时可用 **?:** 放在第一个选项前来消除这种副作用。

其中 **?:** 是非捕获元之一，还有两个非捕获元是 **?=** 和 **?!**，这两个还有更多的含义，前者为正向预查，在任何开始匹配圆括号内的正则表达式模式的位置来匹配搜索字符串，后者为负向预查，在任何开始不匹配该正则表达式模式的位置来匹配搜索字符串。

**以下列出 ?=、?<=、?!、?<! 的使用区别**

**exp1(?=exp2)**：查找 exp2 前面的 exp1。

**(?<=exp2)exp1**：查找 exp2 后面的 exp1。

**exp1(?!exp2)**：查找后面不是 exp2 的 exp1。

**(?<!exp2)exp1**：查找前面不是 exp2 的 exp1。



#### 反向引用

对一个正则表达式模式或部分模式两边添加圆括号将导致相关匹配存储到一个临时缓冲区中，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。缓冲区编号从 1 开始，最多可存储 99 个捕获的子表达式。每个缓冲区都可以使用 **\n** 访问，其中 n 为一个标识特定缓冲区的一位或两位十进制数。

可以使用非捕获元字符 **?:**、**?=** 或 **?!** 来重写捕获，忽略对相关匹配的保存。



```
 /\b([a-z]+) \1\b/igm;
 
\b   单词边界符，用于确保匹配的是完整单词（避免匹配单词内部的子串）。

#([a-z]+)
()：捕获分组，用于提取匹配的内容。
[a-z]+：匹配一个或多个小写字母（构成第一个单词）。
这部分会捕获一个单词，并将其暂存为分组 1。

\1   空格：匹配单词之间的空格。
\1：反向引用，引用第一个分组捕获的内容（即重复前面匹配的单词）。

\b 单词边界符，确保第二个单词也是完整的。

修饰符 igm
i：忽略大小写（使匹配不区分大小写，如 Hello Hello 也能匹配）。
g：全局匹配（找到所有符合条件的结果，而非仅第一个）。
m：多行模式（在多行文本中，\b 仍能正确识别每行的单词边界）。
 
```



#### ---

### 正则表达式 修饰符

正则表达式修饰符（也称为模式修饰符或标记）是用于改变正则表达式匹配行为的特殊指令。

标记也称为修饰符，正则表达式的标记用于指定额外的匹配策略。

标记不写在正则表达式里，标记位于表达式之外，格式如下：

```
/pattern/flags
```

#### 常用修饰符

下表列出了正则表达式常用的修饰符：

1. `i` (ignore case) - 忽略大小写

- 使匹配不区分大小写
- 示例：`/abc/i` 可以匹配 "abc", "Abc", "ABC" 等
- 支持语言：几乎所有正则表达式实现（JavaScript、PHP、Python等）

2. `g` (global) - 全局匹配

- 查找所有匹配项，而不是在第一个匹配后停止
- 示例：在字符串 "ababab" 中，`/ab/g` 会匹配所有三个 "ab"
- 支持语言：JavaScript、PHP等

3. `m` (multiline) - 多行模式

- 改变 `^` 和 `$` 的行为，使其匹配每行的开头和结尾，而不仅是整个字符串的开头和结尾
- 示例：在多行字符串中，`/^abc/m` 会匹配每行开头的 "abc"
- 支持语言：JavaScript、PHP、Python、Perl等

4. `s` (single line/dotall) - 单行模式

- 使点号 `.` 匹配包括换行符在内的所有字符
- 在JavaScript中称为"dotall"模式，使用 `/s` 修饰符
- 示例：`/a.b/s` 可以匹配 "a\nb"
- 支持语言：PHP、Perl、Python(作为`re.DOTALL`)、JavaScript(ES2018+)

5. `u` (unicode) - Unicode模式

- 启用完整的Unicode支持
- 正确处理UTF-16代理对和Unicode字符属性
- 示例：`/\p{Script=Greek}/u` 可以匹配希腊字母
- 支持语言：JavaScript、PHP等

6. `y` (sticky) - 粘性匹配

- 从目标字符串的当前位置开始匹配（使用`lastIndex`属性）
- 类似于`^`锚点，但针对的是匹配的起始位置
- 示例：在JavaScript中，`/a/y` 会从`lastIndex`开始匹配 "a"
- 支持语言：JavaScript

7. `x` (extended) - 扩展模式

- 忽略模式中的空白和注释，使正则表达式更易读
- 示例：在PHP中，`/a b c/x` 等同于 `/abc/`
- 支持语言：PHP、Perl、Python(作为`re.VERBOSE`)



**内联修饰符表（PCRE/Perl风格）：**

| 语法       | 作用范围       | 示例                           |
| :--------- | :------------- | :----------------------------- |
| `(?i)`     | 启用忽略大小写 | `a(?i)bc` → 匹配 "aBc"、"aBC"  |
| `(?-i)`    | 禁用忽略大小写 | `a(?i)b(?-i)c` → 只匹配 "aBc"  |
| `(?i:...)` | 仅对括号内生效 | `a(?i:b)c` → 匹配 "aBc"、"abc" |





##### ----

### 正则表达式 元字符

| 字符                                                       | 描述                                                         |
| :--------------------------------------------------------- | :----------------------------------------------------------- |
| \                                                          | 将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，'n' 匹配字符 "n"。'\n' 匹配一个换行符。序列 '\\' 匹配 "\" 而 "\(" 则匹配 "("。 |
| ^                                                          | 匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 '\n' 或 '\r' 之后的位置。 |
| $                                                          | 匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 '\n' 或 '\r' 之前的位置。 |
| *                                                          | 匹配前面的子表达式零次或多次。例如，zo* 能匹配 "z" 以及 "zoo"。* 等价于{0,}。 |
| +                                                          | 匹配前面的子表达式一次或多次。例如，'zo+' 能匹配 "zo" 以及 "zoo"，但不能匹配 "z"。+ 等价于 {1,}。 |
| ?                                                          | 匹配前面的子表达式零次或一次。例如，"do(es)?" 可以匹配 "do" 或 "does" 。? 等价于 {0,1}。 |
| {n}                                                        | n 是一个非负整数。匹配确定的 n 次。例如，'o{2}' 不能匹配 "Bob" 中的 'o'，但是能匹配 "food" 中的两个 o。 |
| {n,}                                                       | n 是一个非负整数。至少匹配n 次。例如，'o{2,}' 不能匹配 "Bob" 中的 'o'，但能匹配 "foooood" 中的所有 o。'o{1,}' 等价于 'o+'。'o{0,}' 则等价于 'o*'。 |
| {n,m}                                                      | m 和 n 均为非负整数，其中n <= m。最少匹配 n 次且最多匹配 m 次。例如，"o{1,3}" 将匹配 "fooooood" 中的前三个 o。'o{0,1}' 等价于 'o?'。请注意在逗号和两个数之间不能有空格。 |
| ?                                                          | 当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 "oooo"，'o+?' 将匹配单个 "o"，而 'o+' 将匹配所有 'o'。 |
| .                                                          | 匹配除换行符（\n、\r）之外的任何单个字符。要匹配包括 '\n' 在内的任何字符，请使用像"**(.\|\n)**"的模式。 |
| (pattern)                                                  | 匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 '\(' 或 '\)'。 |
| (?:pattern)                                                | 匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 "或" 字符 (\|) 来组合一个模式的各个部分是很有用。例如， 'industr(?:y\|ies) 就是一个比 'industry\|industries' 更简略的表达式。 |
| (?=pattern)                                                | 正向肯定预查（look ahead positive assert），在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，"Windows(?=95\|98\|NT\|2000)"能匹配"Windows2000"中的"Windows"，但不能匹配"Windows3.1"中的"Windows"。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 |
| (?!pattern)                                                | 正向否定预查(negative assert)，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如"Windows(?!95\|98\|NT\|2000)"能匹配"Windows3.1"中的"Windows"，但不能匹配"Windows2000"中的"Windows"。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 |
| (?<=pattern)                                               | 反向(look behind)肯定预查，与正向肯定预查类似，只是方向相反。例如，"`(?<=95|98|NT|2000)Windows`"能匹配"`2000Windows`"中的"`Windows`"，但不能匹配"`3.1Windows`"中的"`Windows`"。 |
| (?<!pattern)                                               | 反向否定预查，与正向否定预查类似，只是方向相反。例如"`(?<!95|98|NT|2000)Windows`"能匹配"`3.1Windows`"中的"`Windows`"，但不能匹配"`2000Windows`"中的"`Windows`"。 |
| x\|y                                                       | 匹配 x 或 y。例如，'z\|food' 能匹配 "z" 或 "food"。'(z\|f)ood' 则匹配 "zood" 或 "food"。 |
| [xyz]                                                      | 字符集合。匹配所包含的任意一个字符。例如， '[abc]' 可以匹配 "plain" 中的 'a'。 |
| [^xyz]                                                     | 负值字符集合。匹配未包含的任意字符。例如， '[^abc]' 可以匹配 "plain" 中的'p'、'l'、'i'、'n'。 |
| [a-z]                                                      | 字符范围。匹配指定范围内的任意字符。例如，'[a-z]' 可以匹配 'a' 到 'z' 范围内的任意小写字母字符。 |
| [^a-z]                                                     | 负值字符范围。匹配任何不在指定范围内的任意字符。例如，'[^a-z]' 可以匹配任何不在 'a' 到 'z' 范围内的任意字符。 |
| [\b](https://www.runoob.com/regexp/regexp-metachar-b.html) | 匹配一个单词边界，也就是指单词和空格间的位置。例如， 'er\b' 可以匹配"never" 中的 'er'，但不能匹配 "verb" 中的 'er'。 |
| [\B](https://www.runoob.com/regexp/regexp-metachar-b.html) | 匹配非单词边界。'er\B' 能匹配 "verb" 中的 'er'，但不能匹配 "never" 中的 'er'。 |
| \cx                                                        | 匹配由 x 指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 'c' 字符。 |
| \d                                                         | 匹配一个数字字符。等价于 [0-9]。                             |
| \D                                                         | 匹配一个非数字字符。等价于 [^0-9]。                          |
| \f                                                         | 匹配一个换页符。等价于 \x0c 和 \cL。                         |
| \n                                                         | 匹配一个换行符。等价于 \x0a 和 \cJ。                         |
| \r                                                         | 匹配一个回车符。等价于 \x0d 和 \cM。                         |
| \s                                                         | 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。 |
| \S                                                         | 匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。                  |
| \t                                                         | 匹配一个制表符。等价于 \x09 和 \cI。                         |
| \v                                                         | 匹配一个垂直制表符。等价于 \x0b 和 \cK。                     |
| \w                                                         | 匹配字母、数字、下划线。等价于'[A-Za-z0-9_]'。               |
| \W                                                         | 匹配非字母、数字、下划线。等价于 '[^A-Za-z0-9_]'。           |
| \xn                                                        | 匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，'\x41' 匹配 "A"。'\x041' 则等价于 '\x04' & "1"。正则表达式中可以使用 ASCII 编码。 |
| \num                                                       | 匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，'(.)\1' 匹配两个连续的相同字符。 |
| \n                                                         | 标识一个八进制转义值或一个向后引用。如果 \n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。 |
| \nm                                                        | 标识一个八进制转义值或一个向后引用。如果 \nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \nm 将匹配八进制转义值 nm。 |
| \nml                                                       | 如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。 |
| \un                                                        | 匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \u00A9 匹配版权符号 (?)。 |





##### ----


### 正则表达式 运算符优先级

| 运算符                      | 描述                                                         |
| :-------------------------- | :----------------------------------------------------------- |
| \                           | 转义符                                                       |
| (), (?:), (?=), []          | 圆括号和方括号                                               |
| *, +, ?, {n}, {n,}, {n,m}   | 限定符                                                       |
| ^, $, \任何元字符、任何字符 | 定位点和序列（即：位置和顺序）                               |
| \|                          | 替换，"或"操作 字符具有高于替换运算符的优先级，使得"m\|food"匹配"m"或"food"。若要匹配"mood"或"food"，请使用括号创建子表达式，从而产生"(m\|f)ood"。 |

##### ----


### 正则表达式 匹配规则

#### 基本模式匹配

一切从最基本的开始。模式，是正则表达式最基本的元素，它们是一组描述字符串特征的字符。模式可以很简单，由普通的字符串组成，也可以非常复杂，往往用特殊的字符表示一个范围内的字符、重复出现，或表示上下文。

#### 字符簇。

要建立一个表示所有元音字符的字符簇，就把所有的元音字符放在一个方括号里：

```
[AaEeIiOoUu]
```

这个模式与任何元音字符匹配，但只能表示一个字符。用连字号可以表示一个字符的范围，如：

```
[a-z] // 匹配所有的小写字母 
[A-Z] // 匹配所有的大写字母 
[a-zA-Z] // 匹配所有的字母 
[0-9] // 匹配所有的数字 
[0-9\.\-] // 匹配所有的数字，句号和减号 
[ \f\r\t\n] // 匹配所有的白字符
```

同样的，这些也只表示一个字符，这是一个非常重要的。如果要匹配一个由一个小写字母和一位数字组成的字符串，比如 "z2"、"t6" 或 "g7"，但不是 "ab2"、"r2d3" 或 "b52" 的话，用这个模式：

```
^[a-z][0-9]$
```

尽管 **[a-z]** 代表 26 个字母的范围，但在这里它只能与第一个字符是小写字母的字符串匹配。

特殊字符 **.**(点，句号)在正则表达式中用来表示除了"新行"之外的所有字符。所以模式 **^.5$** 与任何两个字符的、以数字5结尾和以其他非"新行"字符开头的字符串匹配。模式 **.** 可以匹配任何字符串，**换行符（\n、\r）除外**。



#### 确定重复出现

到现在为止，你已经知道如何去匹配一个字母或数字，但更多的情况下，可能要匹配一个单词或一组数字。一个单词有若干个字母组成，一组数字有若干个单数组成。跟在字符或字符簇后面的花括号({})用来确定前面的内容的重复出现的次数。

| 字符簇           | 描述                            |
| :--------------- | :------------------------------ |
| ^[a-zA-Z_]$      | 所有的字母和下划线              |
| ^[[:alpha:]]{3}$ | 所有的3个字母的单词             |
| ^a$              | 字母a                           |
| ^a{4}$           | aaaa                            |
| ^a{2,4}$         | aa,aaa或aaaa                    |
| ^a{1,3}$         | a,aa或aaa                       |
| ^a{2,}$          | 包含多于两个a的字符串           |
| ^a{2,}           | 如：aardvark和aaab，但apple不行 |
| a{2,}            | 如：baad和aaa，但Nantucket不行  |
| \t{2}            | 两个制表符                      |
| .{2}             | 所有的两个字符                  |



##### ---


### 正则表达式 位置匹配

位置匹配（也称为锚定或边界匹配）是指匹配字符串中的特定位置，而不是实际的字符。与普通字符匹配不同，位置匹配不消耗任何字符，它只是指定匹配必须发生的位置。

### 为什么需要位置匹配

1. **精准定位**：可以精确指定匹配发生的位置
2. **效率提升**：避免不必要的全文搜索
3. **模式验证**：检查字符串是否符合特定格式要求

| 元字符 | 描述                       | 示例       |
| :----- | :------------------------- | :--------- |
| `^`    | 匹配行/字符串开头          | `^Start`   |
| `$`    | 匹配行/字符串结尾          | `end$`     |
| `\b`   | 匹配单词边界               | `\bword\b` |
| `\B`   | 匹配非单词边界             | `\Bword\B` |
| `\A`   | 匹配字符串开头（某些语言） | `\AStart`  |
| `\Z`   | 匹配字符串结尾（某些语言） | `end\Z`    |

掌握位置匹配可以显著提升正则表达式的精确度和效率。记住：

- 位置匹配不消耗字符，只指定匹配发生的位置
- 合理使用边界匹配可以避免不必要的全文搜索
- 多行模式会改变 `^` 和 `$` 的行为





#### ----


### 正则表达式 分组和引用

在正则表达式中，**分组**（Grouping）允许我们将多个字符视为一个整体单元，就像数学中的括号一样。分组主要有两个作用：

1. **将多个字符作为一个整体**：可以对这个整体应用量词（如 `*`、`+`、`?`、`{n}`）
2. **捕获匹配的内容**：可以在后续引用或提取这部分匹配的内容

### 基本语法

使用圆括号 `()` 来创建分组：

```
(表达式)
```

例如，`(ab)+` 可以匹配 "ab"、"abab"、"ababab" 等，但不能匹配 "a" 或 "b"。

| 概念         | 语法                         | 用途                   |
| :----------- | :--------------------------- | :--------------------- |
| 捕获分组     | `(pattern)`                  | 捕获匹配内容并分配编号 |
| 非捕获分组   | `(?:pattern)`                | 分组但不捕获           |
| 命名分组     | `(?P<name>pattern)` (Python) | 为分组指定名称         |
| 反向引用     | `\1`, `\2` 等                | 引用前面匹配的分组     |
| 命名反向引用 | `(?P=name)` (Python)         | 按名称引用分组         |
| 替换引用     | `$1`, `$2` 或 `\1`, `\2`     | 在替换字符串中引用分组 |

掌握正则表达式的分组和引用功能，可以让你：

- 构建更复杂的匹配模式
- 提取和处理字符串中的特定部分
- 实现字符串的智能转换
- 验证复杂的文本结构





#### ----

### 正则表达式 -选择和分支

### 1、什么是选择 (Alternation)

选择（Alternation）是指在正则表达式中使用 **`|`** 符号表示 "或" 的逻辑关系。它允许你匹配多个可能的模式之一。

```
cat|dog
```

这个模式会匹配 "cat" 或 "dog"。

### 2、什么是分支 (Branching)

分支是指正则表达式引擎在匹配过程中遇到选择点时，会尝试不同的匹配路径。当一条路径匹配失败时，引擎会回溯并尝试其他可能的路径。

------

## 原理解析

### 选择操作符 `|` 的工作原理

1. 正则表达式引擎从左到右扫描 **`|`** 分隔的各个选项
2. 尝试匹配第一个选项，如果成功则停止
3. 如果第一个选项不匹配，则尝试第二个选项
4. 依此类推，直到找到匹配或所有选项都尝试完毕

### 分组与选择

选择通常与分组 **`()`** 结合使用，以限定选择的范围：

## 实例

gr(a|e)y

这个模式会匹配 "gray" 或 "grey"。

### 分支回溯机制

当正则表达式引擎遇到选择点时：

1. 记住当前位置（创建检查点）
2. 尝试第一个分支
3. 如果失败，回退到检查点
4. 尝试下一个分支
5. 重复直到成功或所有分支都尝试过



## 扩展应用

### 性能优化技巧

1. **高频选项前置**：将最可能匹配的选项放在前面

   ```
   (common|uncommon|rare)  # 优化顺序
   ```

2. **避免冗余分支**：

   ```
   (a|ab|c)  # 不好
   (ab?|c)   # 更好
   ```

3. **使用非捕获组**：当不需要捕获分组时

   ```
   (?:pattern1|pattern2)
   ```

### 实际应用场景

1. **日志分析**：匹配多种错误消息格式
2. **表单验证**：接受多种合法输入格式
3. **文本处理**：查找同义词或变体拼写
4. **路由匹配**：Web框架中的URL路由



#### ----

### 正则表达式 断言

断言（Assertion）是正则表达式中用于指定匹配位置的元字符，它们不匹配任何实际字符，而是匹配字符之间的位置。**判断某个位置是否满足特定条件**（即 “断言” 这个位置的前后环境）。

简单来说，断言就是"条件"，它要求目标字符串必须满足某些条件，但不会消耗字符。

##### 断言的特点

1. **零宽度**：不占用匹配字符的位置
2. **条件检查**：只检查是否满足特定条件
3. **不影响匹配结果**：仅作为匹配的约束条件

##### 断言的类型

正则表达式中的断言主要分为两大类四种类型：

**正向断言**（肯定条件）和**负向断言**（否定条件），按位置又可分为**先行断言**（判断后面的内容）和**后行断言**（判断前面的内容）。

**1. 先行断言（Lookahead Assertions）**

检查当前位置之后是否匹配特定模式

**正向先行断言（Positive Lookahead）**

1. **正向先行断言（Positive Lookahead）**

- **语法**：`(?=pattern)`
- **作用**：断言当前位置**后面**必须匹配 `pattern`，但不包含 `pattern` 本身在匹配结果中。

实例

```
*// 匹配后面跟着数字的字母*
**const** regex = */[a-z](?=\d)/*;
console.log("a1".match(regex)); *// ["a"]*
```

2. **负向先行断言（Negative Lookahead）**

- **语法**：`(?!pattern)`
- **作用**：断言当前位置**后面**必须**不**匹配 `pattern`。

 实例

```
*// 匹配后面不跟着数字的字母*
**const** regex = */[a-z](?!\d)/*;
console.log("ab".match(regex)); *// ["a"]*
```

2. **正向后行断言（Positive Lookbehind）**
   - **语法**：`(?<=pattern)`
   - **作用**：断言当前位置**前面**必须匹配 `pattern`，但不包含 `pattern` 本身在匹配结果中。

 实例

```
*// 匹配前面是$符号的数字*
**const** regex = */(?<=\$)\d+/*;
console.log("$100".match(regex)); *// ["100"]*
```

. **负向后行断言（Negative Lookbehind）**

- **语法**：`(?<!pattern)`
- **作用**：断言当前位置**前面**必须**不**匹配 `pattern`。

实例

```
*// 匹配前面不是$符号的数字*
**const** regex = */(?<!\$)\d+/*;
console.log("€100".match(regex)); *// ["100"]*
```

------

##### 断言的应用场景

1. **密码强度验证**

要求密码包含至少一个大写字母、一个小写字母和一个数字，但不以数字开头：

实例

```
**const** passwordRegex = */^(?=.\*[a-z])(?=.\*[A-Z])(?=.\*\d)[A-Za-z]\w{7,}$/*;
console.log(passwordRegex.test("Password1")); *// true*
console.log(passwordRegex.test("password1")); *// false (缺少大写)*
```

| 组成部分      | 语法含义                                                     |
| ------------- | ------------------------------------------------------------ |
| `^`           | 匹配字符串**开始位置**，确保密码从这里开始，无前置字符。     |
| `(?=.*[a-z])` | 正向先行断言：要求字符串中**至少包含 1 个小写字母**（`[a-z]`），`.*`表示任意字符（除换行）可在小写字母前。 |
| `(?=.*[A-Z])` | 正向先行断言：要求字符串中**至少包含 1 个大写字母**（`[A-Z]`）。 |
| `(?=.*\d)`    | 正向先行断言：要求字符串中**至少包含 1 个数字**（`\d`等价于`[0-9]`）。 |
| `[A-Za-z]`    | 匹配 1 个字母（大写或小写），作为密码的**第一个字符**（强制密码以字母开头）。 |
| `\w{7,}`      | - `\w`：匹配字母、数字或下划线（`[A-Za-z0-9_]`）； - `{7,}`：要求前面的`\w`至少出现 7 次。 |
| `$`           | 匹配字符串**结束位置**，确保密码到这里结束，无后置字符。     |



2. **提取特定格式的数据**

从文本中提取不在引号内的数字：

实例

```
**const** text = '123 "456" 789 "101"';
**const** regex = */(?<!")\b\d+\b(?!")/g*;
console.log(text.match(regex)); *// ["123", "789"]*
```

3. **替换特定模式的文本**

将不在HTML标签内的"foo"替换为"bar"：

实例

```
**const** html = '<div>foo</div> foo <span>foo</span>';
**const** regex = */foo(?![^<]\*>)/g*;
console.log(html.replace(regex, 'bar'));
*// "<div>foo</div> bar <span>foo</span>"*
```

------

##### 断言的执行原理

理解断言的工作原理有助于更好地使用它们：

![img](C:\Users\lin\Downloads\github\Typora\img\runoob-assert.png)

1. 正则引擎遇到断言时，会暂停当前匹配
2. 检查断言指定的条件是否满足
3. 如果满足，继续匹配后续模式（不消耗字符）
4. 如果不满足，整个匹配失败

##### ---

### 正则表达式 示例





### 正则表达式 使用总结



### 正则表达式入门教程

#### 基本语法

- **普通字符**：直接匹配与自身相同的字符，且区分大小写。例如，正则表达式 “abc” 就只能匹配字符串 “abc” 中的这三个连续字符。

- 元字符

  ：具有特殊含义的字符，赋予了正则表达式强大的模式匹配能力。常见的元字符如下：

  - **点号（.）**：匹配除换行符（\n）之外的任意单个字符。如 “a.c” 可以匹配 “abc”“aec” 等。
  - **脱字符（^）**：用于匹配字符串的开始位置。如 “^abc” 表示匹配以 “abc” 开头的字符串。
  - $ 美元符号（）：用于匹配字符串的结束位置。如” 表示匹配以 “abc” 结尾的字符串。
  - **星号（\*）**：表示匹配其前面的字符或子表达式零次或多次。如 “ab*c” 可以匹配 “ac”“abc”“abbc” 等。
  - **加号（+）**：表示匹配其前面的字符或子表达式一次或多次，即至少出现一次。如 “ab+c” 可以匹配 “abc”“abbc” 等，但不能匹配 “ac”。
  - **问号（?）**：一是表示匹配其前面的字符或子表达式零次或一次，即可选出现；二是用于非贪婪匹配模式。如 “ab?c” 可以匹配 “ac” 或 “abc”。
  - **方括号（[]）**：用于定义一个字符集合，匹配该集合中的任意一个字符。如 “[abc]” 表示匹配 a、b 或 c 中的任意一个字符；“[a - z]” 表示匹配小写字母 a 到 z 中的任意一个。
  - **大括号（{}）**：用于指定其前面的字符或子表达式的出现次数。如 “a {3}” 表示匹配 a 恰好出现 3 次；“a {2,5}” 表示匹配 a 出现 2 到 5 次。
  - **竖线（|）**：用于表示逻辑 “或” 关系，即匹配其左右两边的任意一个子表达式。如 “ab|cd” 可以匹配 “ab” 或 “cd”。
  - **反斜杠（\）**：用于转义元字符，使其失去特殊含义，作为普通字符匹配。如要匹配点号（.）本身，就需要使用 `\.`。此外，反斜杠还与一些字母组合形成预定义的字符类，如 “\d” 匹配任意一个数字，等价于 “[0 - 9]”。

#### 匹配模式

- **贪婪匹配与非贪婪匹配**：默认情况下，量词是贪婪的，即尽可能多地匹配字符。如对于字符串 “aabbaabb”，正则表达式 “a.*b” 会匹配整个字符串 “aabbaabb”。而如果希望量词进行非贪婪匹配，即尽可能少地匹配字符，可以在量词后面加上问号（?）。如 “a.*?b” 会匹配第一个 “a” 和第一个 “b” 之间的内容，即 “aab”。
- **忽略大小写匹配**：在很多情况下，希望匹配字符时不区分大小写。在 Python 中，可以使用 re.IGNORECASE 标志（或简写为 re.I）；在 JavaScript 中，可以在正则表达式末尾添加 “i” 标志。如正则表达式 “/abc/i” 可以匹配 “abc”“ABC”“AbC” 等。
- **多行匹配模式**：默认情况下，正则表达式中的脱字符（^）和美元符号（$）只匹配整个字符串的开始和结束位置。但在多行文本中，可能希望它们匹配每一行的开始和结束位置。在 Python 中，使用 re.MULTILINE 标志（或简写为 re.M）；在 JavaScript 中，在正则表达式末尾添加 “m” 标志。

#### 分组与捕获

- **捕获分组**：使用括号 “()” 进行分组，括号内的内容会被捕获，可以通过 “\1”“\2” 等引用。如 “(abc)\1” 可以匹配 “abcabc”，其中 “\1” 引用了第一个括号内的 “abc”。
- **非捕获分组**：使用 “(?:pattern)” 表示非捕获分组，它只进行匹配但不捕获内容，适用于需要分组但不需要提取子字符串的情况。

#### 实战应用

- **匹配邮箱地址**：邮箱地址的格式通常为 “username@domain.com”，可以用正则表达式 “^[a-zA - Z0 - 9._%+-]+@[a-zA - Z0 - 9.-]+.[a-zA - Z]{2,}$” 来匹配。
- **匹配 URL**：可以使用正则表达式 “https?://([a-zA - Z0 - 9.-]+)/?” 来匹配 URL，并提取其中的域名部分。
- 

### 正则表达式 测验



### 正则表达式 选择和分支



